{"0": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "HF-PCAL95555 Driver",
    "content": "Hardware-agnostic C++ driver for the NXP PCA9555 and PCAL9555A 16-bit I/O expanders . ",
    "url": "/hf-pcal95555-driver/development/#hf-pcal95555-driver",
    
    "relUrl": "/#hf-pcal95555-driver"
  },"1": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Table of Contents",
    "content": ". | Overview | Chip Compatibility | Features | Project Structure | Quick Start | Installation | Building and Flashing (ESP32) | API Reference | Examples | Testing | Hardware Setup | Troubleshooting | Contributing | License | . ",
    "url": "/hf-pcal95555-driver/development/#table-of-contents",
    
    "relUrl": "/#table-of-contents"
  },"2": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Overview",
    "content": "üìñ üìöüåê Live Complete Documentation - Interactive guides, examples, and step-by-step tutorials . The PCA9555 and PCAL9555A are 16-bit I/O expanders from NXP Semiconductors that communicate via I2C. They provide 16 GPIO pins organized into two 8-bit ports (PORT_0: pins 0-7, PORT_1: pins 8-15), expanding your microcontroller‚Äôs I/O capabilities over a simple two-wire bus. This driver provides a single, unified C++ class that supports both chip variants. The chip type is auto-detected during initialization by probing the extended register bank. Features exclusive to the PCAL9555A degrade gracefully when a standard PCA9555 is detected. The driver is hardware-agnostic ‚Äì it uses the CRTP (Curiously Recurring Template Pattern) for zero-overhead I2C abstraction. You only need to implement a small I2cInterface class for your platform. ",
    "url": "/hf-pcal95555-driver/development/#overview",
    
    "relUrl": "/#overview"
  },"3": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Chip Compatibility",
    "content": "The PCAL9555A is a pin-compatible superset of the PCA9555. The driver handles both transparently: . | Feature | PCA9555 | PCAL9555A | . | 16 GPIO pins (2 x 8-bit ports) | Yes | Yes | . | I2C addresses 0x20-0x27 | Yes | Yes | . | Pin direction (input/output) | Yes | Yes | . | Pin read / write / toggle | Yes | Yes | . | Polarity inversion | Yes | Yes | . | Pull-up / pull-down resistors | ‚Äì | Yes | . | Drive strength (4 levels) | ‚Äì | Yes | . | Input latch | ‚Äì | Yes | . | Interrupt mask / status | ‚Äì | Yes | . | Output mode (push-pull / OD) | ‚Äì | Yes | . How detection works: During initialization, the driver reads a standard register (INPUT_PORT_0, 0x00) to verify the bus is alive, then probes the Agile I/O register (OUTPUT_CONF, 0x4F). If the chip ACKs, it‚Äôs a PCAL9555A. If it NACKs, it‚Äôs a PCA9555. A follow-up read of INPUT_PORT_0 confirms the bus recovered. This 3-step sandwich ensures reliable detection even on noisy buses. Methods requiring PCAL9555A features return false and set Error::UnsupportedFeature when called on a PCA9555. You can check at runtime with: . | 1 2 3 4 . | if (driver.HasAgileIO()) { // PCAL9555A features available driver.SetDriveStrength(0, DriveStrength::Level2); } . | . ",
    "url": "/hf-pcal95555-driver/development/#chip-compatibility",
    
    "relUrl": "/#chip-compatibility"
  },"4": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Features",
    "content": ". | Dual-chip support: Auto-detects PCA9555 vs PCAL9555A at runtime | 16 GPIO Pins: Two 8-bit ports (PORT_0: pins 0-7, PORT_1: pins 8-15) | Per-pin configuration: Direction, pull-up/pull-down, drive strength, polarity | Interrupt support: Per-pin interrupt masking with edge-detection callbacks | Hardware agnostic: CRTP-based I2C interface for platform independence | Modern C++17: Template-based design with std::initializer_list multi-pin APIs | Zero overhead: CRTP for compile-time polymorphism ‚Äì no virtual calls | Lazy initialization: No I2C traffic in the constructor; init on first use | Kconfig integration: Optional compile-time configuration via ESP-IDF Kconfig | Robust error handling: Bitmask error flags, configurable I2C retries | Graceful degradation: PCAL9555A features fail cleanly on PCA9555 | . ",
    "url": "/hf-pcal95555-driver/development/#features",
    
    "relUrl": "/#features"
  },"5": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Project Structure",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 . | hf-pcal95555-driver/ ‚îú‚îÄ‚îÄ inc/ ‚îÇ ‚îú‚îÄ‚îÄ pcal95555.hpp # Main driver header (public API) ‚îÇ ‚îú‚îÄ‚îÄ pcal95555_kconfig.hpp # Kconfig compile-time configuration macros ‚îÇ ‚îî‚îÄ‚îÄ pcal95555_i2c_interface.hpp # CRTP I2C interface base class ‚îú‚îÄ‚îÄ src/ ‚îÇ ‚îî‚îÄ‚îÄ pcal95555.ipp # Template implementation (included by header) ‚îú‚îÄ‚îÄ examples/ ‚îÇ ‚îî‚îÄ‚îÄ esp32/ ‚îÇ ‚îú‚îÄ‚îÄ main/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ esp32_pcal95555_bus.hpp # ESP32 I2C implementation ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ pcal95555_comprehensive_test.cpp # Full API test suite ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ pcal95555_led_animation.cpp # LED animation demo ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ TestFramework.h # Test harness macros ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ CMakeLists.txt # Build configuration ‚îÇ ‚îú‚îÄ‚îÄ scripts/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ build_app.sh # Build script ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ flash_app.sh # Flash + monitor script ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ config_loader.sh # Build config parser ‚îÇ ‚îú‚îÄ‚îÄ app_config.yml # App definitions for build system ‚îÇ ‚îî‚îÄ‚îÄ sdkconfig # ESP-IDF configuration ‚îú‚îÄ‚îÄ datasheet/ ‚îÇ ‚îî‚îÄ‚îÄ PCAL9555A.pdf # NXP datasheet ‚îú‚îÄ‚îÄ _config/ # Doxygen configuration ‚îú‚îÄ‚îÄ docs/ # Additional documentation ‚îú‚îÄ‚îÄ README.md # This file ‚îî‚îÄ‚îÄ LICENSE # GPLv3 . | . ",
    "url": "/hf-pcal95555-driver/development/#project-structure",
    
    "relUrl": "/#project-structure"
  },"6": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Quick Start",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/#quick-start",
    
    "relUrl": "/#quick-start"
  },"7": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "1. Implement the I2C interface for your platform",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . | #include \"pcal95555.hpp\" class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t* data, size_t len) { // Your platform I2C write implementation } bool Read(uint8_t addr, uint8_t reg, uint8_t* data, size_t len) { // Your platform I2C read implementation } bool SetAddressPins(bool a0, bool a1, bool a2) { return false; // Return false if address pins are hardwired } }; . | . ",
    "url": "/hf-pcal95555-driver/development/#1-implement-the-i2c-interface-for-your-platform",
    
    "relUrl": "/#1-implement-the-i2c-interface-for-your-platform"
  },"8": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "2. Create the driver and use it",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 . | MyI2c i2c; // Option A: Address pin levels (A0=LOW, A1=LOW, A2=LOW -&gt; 0x20) pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, false, false, false); // Option B: Direct I2C address pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); // Option C: Force chip variant (skip auto-detection) pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20, pcal95555::ChipVariant::PCA9555); // Use the driver gpio.SetPinDirection(0, GPIODir::Output); gpio.WritePin(0, true); // Turn on pin 0 bool state = gpio.ReadPin(1); // Read pin 1 // Check chip variant if (gpio.HasAgileIO()) { gpio.SetDriveStrength(0, DriveStrength::Level3); gpio.SetPullEnable(1, true); gpio.SetPullDirection(1, true); // pull-up } // Multi-pin operations gpio.WritePins({{0, true}, {1, false}, {2, true}}); gpio.SetDirections({{0, GPIODir::Output}, {1, GPIODir::Input}}); . | . ",
    "url": "/hf-pcal95555-driver/development/#2-create-the-driver-and-use-it",
    
    "relUrl": "/#2-create-the-driver-and-use-it"
  },"9": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Installation",
    "content": "This is a header-only template library with implementation included via #include. ",
    "url": "/hf-pcal95555-driver/development/#installation",
    
    "relUrl": "/#installation"
  },"10": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Method 1: Copy into your project",
    "content": "| 1 2 . | cp -r inc/ /path/to/your/project/drivers/pcal95555/ cp -r src/ /path/to/your/project/drivers/pcal95555/ . | . ",
    "url": "/hf-pcal95555-driver/development/#method-1-copy-into-your-project",
    
    "relUrl": "/#method-1-copy-into-your-project"
  },"11": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Method 2: Git submodule",
    "content": "| 1 . | git submodule add https://github.com/N3b3x/hf-pcal95555-driver.git lib/pcal95555 . | . ",
    "url": "/hf-pcal95555-driver/development/#method-2-git-submodule",
    
    "relUrl": "/#method-2-git-submodule"
  },"12": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Method 3: ESP-IDF component (recommended for ESP32)",
    "content": "Add as a managed component or place in your project‚Äôs components/ directory. ",
    "url": "/hf-pcal95555-driver/development/#method-3-esp-idf-component-recommended-for-esp32",
    
    "relUrl": "/#method-3-esp-idf-component-recommended-for-esp32"
  },"13": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Requirements",
    "content": ". | C++17 or newer compiler | An I2C peripheral driver for your platform | . ",
    "url": "/hf-pcal95555-driver/development/#requirements",
    
    "relUrl": "/#requirements"
  },"14": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Building and Flashing (ESP32)",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/#building-and-flashing-esp32",
    
    "relUrl": "/#building-and-flashing-esp32"
  },"15": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Prerequisites",
    "content": ". | ESP-IDF v5.5+ | ESP32-S3 development board with PCA9555 or PCAL9555A connected via I2C | . ",
    "url": "/hf-pcal95555-driver/development/#prerequisites",
    
    "relUrl": "/#prerequisites"
  },"16": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Build",
    "content": "| 1 2 3 4 5 6 7 8 9 10 . | cd examples/esp32 # List available apps ./scripts/build_app.sh list # Build the comprehensive test suite ./scripts/build_app.sh pcal95555_comprehensive_test Debug # Build the LED animation demo ./scripts/build_app.sh pcal95555_led_animation Debug . | . ",
    "url": "/hf-pcal95555-driver/development/#build",
    
    "relUrl": "/#build"
  },"17": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Flash and Monitor",
    "content": "| 1 2 3 4 5 6 7 8 . | # Flash and open serial monitor ./scripts/flash_app.sh flash_monitor pcal95555_comprehensive_test Debug # Flash only ./scripts/flash_app.sh flash pcal95555_comprehensive_test Debug # Monitor only (if already flashed) ./scripts/flash_app.sh monitor . | . Note (ESP32-S3 native USB): If using the USB-SERIAL-JTAG port (/dev/ttyACM0), you may need to manually enter download mode: Hold BOOT, press RESET, release BOOT, then immediately run the flash command. ",
    "url": "/hf-pcal95555-driver/development/#flash-and-monitor",
    
    "relUrl": "/#flash-and-monitor"
  },"18": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "API Reference",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/#api-reference",
    
    "relUrl": "/#api-reference"
  },"19": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Initialization",
    "content": "| Method | Description | . | PCAL95555(bus, a0, a1, a2, variant) | Construct from address pin levels | . | PCAL95555(bus, address, variant) | Construct from I2C address (0x20-0x27) | . | EnsureInitialized() | Explicitly trigger lazy initialization | . | ResetToDefault() | Reset all registers to power-on defaults | . | InitFromConfig() | Initialize from Kconfig compile-time values | . ",
    "url": "/hf-pcal95555-driver/development/#initialization",
    
    "relUrl": "/#initialization"
  },"20": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "GPIO Direction",
    "content": "| Method | Description | . | SetPinDirection(pin, dir) | Set single pin input/output | . | SetMultipleDirections(mask, dir) | Set direction by 16-bit mask | . | SetDirections({...}) | Set mixed directions via initializer list | . ",
    "url": "/hf-pcal95555-driver/development/#gpio-direction",
    
    "relUrl": "/#gpio-direction"
  },"21": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Pin Read / Write",
    "content": "| Method | Description | . | ReadPin(pin) | Read single pin state | . | WritePin(pin, value) | Write single pin HIGH/LOW | . | TogglePin(pin) | Toggle single pin | . | ReadPins({...}) | Read multiple pins at once | . | WritePins({...}) | Write multiple pins at once | . ",
    "url": "/hf-pcal95555-driver/development/#pin-read--write",
    
    "relUrl": "/#pin-read--write"
  },"22": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Pull Resistors (PCAL9555A only)",
    "content": "| Method | Description | . | SetPullEnable(pin, enable) | Enable/disable pull resistor | . | SetPullEnables({...}) | Multi-pin pull enable | . | SetPullDirection(pin, pull_up) | Select pull-up or pull-down | . | SetPullDirections({...}) | Multi-pin pull direction | . ",
    "url": "/hf-pcal95555-driver/development/#pull-resistors-pcal9555a-only",
    
    "relUrl": "/#pull-resistors-pcal9555a-only"
  },"23": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Drive Strength (PCAL9555A only)",
    "content": "| Method | Description | . | SetDriveStrength(pin, level) | Set drive strength (Level0-Level3) | . | SetDriveStrengths({...}) | Multi-pin drive strength | . ",
    "url": "/hf-pcal95555-driver/development/#drive-strength-pcal9555a-only",
    
    "relUrl": "/#drive-strength-pcal9555a-only"
  },"24": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Interrupts",
    "content": "| Method | Description | PCAL9555A? | . | ConfigureInterrupt(pin, state) | Enable/disable per-pin interrupt | Yes | . | ConfigureInterrupts({...}) | Multi-pin interrupt config | Yes | . | ConfigureInterruptMask(mask) | Set 16-bit interrupt mask | Yes | . | GetInterruptStatus() | Read and clear interrupt status | Yes | . | RegisterPinInterrupt(pin, edge, cb) | Register edge-triggered callback | No | . | UnregisterPinInterrupt(pin) | Remove pin callback | No | . | SetInterruptCallback(cb) | Register global interrupt callback | No | . | RegisterInterruptHandler() | Bind to hardware INT pin | No | . | HandleInterrupt() | Process interrupt (auto or manual) | No | . ",
    "url": "/hf-pcal95555-driver/development/#interrupts",
    
    "relUrl": "/#interrupts"
  },"25": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Polarity",
    "content": "| Method | Description | . | SetPinPolarity(pin, polarity) | Set input polarity (normal/inverted) | . | SetMultiplePolarities(mask, pol) | Set polarity by mask | . | SetPolarities({...}) | Multi-pin polarity via initializer list | . ",
    "url": "/hf-pcal95555-driver/development/#polarity",
    
    "relUrl": "/#polarity"
  },"26": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Input Latch (PCAL9555A only)",
    "content": "| Method | Description | . | EnableInputLatch(pin, enable) | Enable/disable input latch | . | EnableMultipleInputLatches(mask, en) | Mask-based latch control | . | EnableInputLatches({...}) | Multi-pin latch via initializer list | . ",
    "url": "/hf-pcal95555-driver/development/#input-latch-pcal9555a-only",
    
    "relUrl": "/#input-latch-pcal9555a-only"
  },"27": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Output Mode (PCAL9555A only)",
    "content": "| Method | Description | . | SetOutputMode(p0_od, p1_od) | Set push-pull or open-drain per port | . ",
    "url": "/hf-pcal95555-driver/development/#output-mode-pcal9555a-only",
    
    "relUrl": "/#output-mode-pcal9555a-only"
  },"28": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Address Management",
    "content": "| Method | Description | . | GetAddress() | Get current 7-bit I2C address | . | GetAddressBits() | Get A2-A0 bits (0-7) | . | ChangeAddress(a0, a1, a2) | Change address via pin levels | . | ChangeAddress(address) | Change address directly (0x20-0x27) | . ",
    "url": "/hf-pcal95555-driver/development/#address-management",
    
    "relUrl": "/#address-management"
  },"29": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Error Handling",
    "content": "| Method | Description | . | GetErrorFlags() | Get bitmask of active errors | . | ClearErrorFlags(mask) | Clear specific or all error flags | . | SetRetries(n) | Set I2C retry count | . | HasAgileIO() | Check if PCAL9555A features available | . | GetChipVariant() | Get detected variant enum | . ",
    "url": "/hf-pcal95555-driver/development/#error-handling",
    
    "relUrl": "/#error-handling"
  },"30": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Error Flags",
    "content": "| Flag | Value | Meaning | . | InvalidPin | 0x0001 | Pin index &gt;= 16 | . | InvalidMask | 0x0002 | Mask bits outside 0-15 | . | I2CReadFail | 0x0004 | I2C read transaction failed | . | I2CWriteFail | 0x0008 | I2C write transaction failed | . | UnsupportedFeature | 0x0010 | PCAL9555A feature called on PCA9555 | . | InvalidAddress | 0x0020 | I2C address outside valid 0x20-0x27 range | . ",
    "url": "/hf-pcal95555-driver/development/#error-flags",
    
    "relUrl": "/#error-flags"
  },"31": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Examples",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/#examples",
    
    "relUrl": "/#examples"
  },"32": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Comprehensive Test Suite (pcal95555_comprehensive_test)",
    "content": "A thorough test of every public API method, organized into 17 test sections: . | Initialization (I2C bus, driver, chip variant detection) | GPIO direction (single pin, multi-pin mask, initializer list) | GPIO read/write (ReadPin, WritePin, TogglePin, WritePins, ReadPins) | Pull resistor configuration (single + multi-pin, PCAL9555A) | Drive strength (single + multi-pin, PCAL9555A) | Output mode (push-pull / open-drain, PCAL9555A) | Polarity inversion (single, mask, initializer list) | Input latch (single, mask, initializer list, PCAL9555A) | Interrupt configuration (mask, status, callbacks, handler, PCAL9555A) | Port-level operations | Multi-pin API tests (WritePins, ReadPins, SetDirections, SetPolarities) | Address management (ChangeAddress, address-based constructor) | Configuration (SetRetries, EnsureInitialized) | Multi-pin PCAL9555A APIs (SetPullEnables, SetDriveStrengths, ConfigureInterrupts, etc.) | Interactive input (button press test, disabled by default) | Error handling (invalid pins, UnsupportedFeature, selective flag clearing) | Stress tests (rapid pin toggling) | . PCAL9555A-only tests are automatically skipped (not failed) on a standard PCA9555. To enable the interactive input test (requires a physical button on pin 0): . | 1 . | static constexpr bool ENABLE_INTERACTIVE_INPUT_TESTS = true; . | . ",
    "url": "/hf-pcal95555-driver/development/#comprehensive-test-suite-pcal95555_comprehensive_test",
    
    "relUrl": "/#comprehensive-test-suite-pcal95555_comprehensive_test"
  },"33": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "LED Animation Demo (pcal95555_led_animation)",
    "content": "A visual demo driving 16 LEDs through 10 animation patterns: . | Sequential Chase ‚Äì single LED scans left/right | Bounce ‚Äì LED bounces between endpoints | Binary Counter ‚Äì counts 0-65535 in binary on LEDs | Breathing (PWM) ‚Äì software PWM fade-in/fade-out | Wave / Comet Tail ‚Äì 4-LED comet sweeps back and forth | Random Sparkle ‚Äì random LED patterns | Build-up / Teardown ‚Äì LEDs light up then extinguish one by one | Accelerating Scan ‚Äì speed ramps from 120ms to 1ms and back | Center Expand / Contract ‚Äì symmetric outward/inward animation | Alternating Flash ‚Äì port-vs-port and even-vs-odd flashing | . Configure LEDS_ACTIVE_LOW for your wiring (common-anode vs common-cathode). ",
    "url": "/hf-pcal95555-driver/development/#led-animation-demo-pcal95555_led_animation",
    
    "relUrl": "/#led-animation-demo-pcal95555_led_animation"
  },"34": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Testing",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/#testing",
    
    "relUrl": "/#testing"
  },"35": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Running on hardware",
    "content": "| 1 2 3 4 . | # Build and flash the test suite cd examples/esp32 ./scripts/build_app.sh pcal95555_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pcal95555_comprehensive_test Debug . | . ",
    "url": "/hf-pcal95555-driver/development/#running-on-hardware",
    
    "relUrl": "/#running-on-hardware"
  },"36": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Expected output (PCA9555)",
    "content": "| 1 2 3 4 5 . | Detected chip variant: PCA9555 (standard) Agile I/O support: NO Total: 31, Passed: 31, Failed: 0, Success: 100.00% ALL PCAL9555 TESTS PASSED! . | . PCAL9555A-only tests will show: . | 1 . | Skipping: Pull resistor config requires PCAL9555A (detected PCA9555) . | . ",
    "url": "/hf-pcal95555-driver/development/#expected-output-pca9555",
    
    "relUrl": "/#expected-output-pca9555"
  },"37": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Expected output (PCAL9555A)",
    "content": "| 1 2 3 4 5 . | Detected chip variant: PCAL9555A (Agile I/O) Agile I/O support: YES Total: 31, Passed: 31, Failed: 0, Success: 100.00% ALL PCAL9555 TESTS PASSED! . | . ",
    "url": "/hf-pcal95555-driver/development/#expected-output-pcal9555a",
    
    "relUrl": "/#expected-output-pcal9555a"
  },"38": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Test configuration",
    "content": "Each test section can be individually enabled/disabled at the top of the test file: . | 1 2 3 4 . | static constexpr bool ENABLE_INITIALIZATION_TESTS = true; static constexpr bool ENABLE_GPIO_DIRECTION_TESTS = true; // ... etc static constexpr bool ENABLE_INTERACTIVE_INPUT_TESTS = false; // Requires button . | . ",
    "url": "/hf-pcal95555-driver/development/#test-configuration",
    
    "relUrl": "/#test-configuration"
  },"39": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Hardware Setup",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/#hardware-setup",
    
    "relUrl": "/#hardware-setup"
  },"40": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Minimal wiring (ESP32-S3 + PCA9555/PCAL9555A)",
    "content": "| 1 2 3 4 5 6 7 8 9 . | ESP32-S3 PCA9555 / PCAL9555A ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GPIO4 (SDA) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDA GPIO5 (SCL) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCL 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VSS (GND) A0 ‚îÄ‚îÄ‚îÄ GND (or GPIO45) A1 ‚îÄ‚îÄ‚îÄ GND (or GPIO48) A2 ‚îÄ‚îÄ‚îÄ GND (or GPIO47) . | . Pull-up resistors: 4.7kŒ© on SDA and SCL to 3.3V (or enable internal pull-ups). Address: The I2C address is 0x20 + (A2&lt;&lt;2 | A1&lt;&lt;1 | A0). Default with all address pins LOW is 0x20. ",
    "url": "/hf-pcal95555-driver/development/#minimal-wiring-esp32-s3--pca9555pcal9555a",
    
    "relUrl": "/#minimal-wiring-esp32-s3--pca9555pcal9555a"
  },"41": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "LED animation demo wiring",
    "content": "Connect LEDs with current-limiting resistors (220Œ©-1kŒ©) to each I/O pin. For active-HIGH: LED anode to IO pin, cathode to GND. For active-LOW: LED cathode to IO pin, anode to VDD through resistor. ",
    "url": "/hf-pcal95555-driver/development/#led-animation-demo-wiring",
    
    "relUrl": "/#led-animation-demo-wiring"
  },"42": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Interactive test wiring",
    "content": "Connect a momentary push-button between PCA9555 pin IO0_0 and GND. For PCAL9555A, the internal pull-up is enabled automatically. For PCA9555, add an external 10kŒ© pull-up resistor to VDD. ",
    "url": "/hf-pcal95555-driver/development/#interactive-test-wiring",
    
    "relUrl": "/#interactive-test-wiring"
  },"43": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Troubleshooting",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/#troubleshooting",
    
    "relUrl": "/#troubleshooting"
  },"44": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "‚ÄúI2C transaction unexpected nack detected‚Äù",
    "content": "| Symptom | Cause | Fix | . | NACK on all registers | Wrong I2C address or chip not powered | Verify wiring, address pins, power | . | NACK on 0x40-0x4F only | Standard PCA9555 (no Agile I/O) | Expected behavior ‚Äì driver auto-detects | . | Intermittent NACKs | Bus noise, missing pull-ups | Add 4.7kŒ© pull-ups, reduce bus speed | . ",
    "url": "/hf-pcal95555-driver/development/#i2c-transaction-unexpected-nack-detected",
    
    "relUrl": "/#i2c-transaction-unexpected-nack-detected"
  },"45": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Stack overflow on ESP32",
    "content": "The default main_task stack may be too small for the test suite (extensive logging). Set in sdkconfig: . | 1 . | CONFIG_ESP_MAIN_TASK_STACK_SIZE=16384 . | . ",
    "url": "/hf-pcal95555-driver/development/#stack-overflow-on-esp32",
    
    "relUrl": "/#stack-overflow-on-esp32"
  },"46": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "ESP32-S3 flashing fails",
    "content": "If using native USB (/dev/ttyACM0), the auto-reset circuit may not work reliably. Manually enter download mode: Hold BOOT ‚Üí Press RESET ‚Üí Release BOOT ‚Üí Run flash command immediately. ",
    "url": "/hf-pcal95555-driver/development/#esp32-s3-flashing-fails",
    
    "relUrl": "/#esp32-s3-flashing-fails"
  },"47": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "ChipVariant shows ‚ÄúUnknown‚Äù",
    "content": "This means the 3-step detection could not confirm the chip type (bus error during probe). Check wiring, pull-ups, and power supply. ",
    "url": "/hf-pcal95555-driver/development/#chipvariant-shows-unknown",
    
    "relUrl": "/#chipvariant-shows-unknown"
  },"48": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "Contributing",
    "content": "Pull requests and suggestions are welcome! Please: . | Follow the existing code style (clang-format, Doxygen comments) | Add tests for new features in the comprehensive test suite | Update documentation for any API changes | Ensure the build passes for both Debug and Release configurations | . ",
    "url": "/hf-pcal95555-driver/development/#contributing",
    
    "relUrl": "/#contributing"
  },"49": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "License",
    "content": "This project is licensed under the GNU General Public License v3.0. See the LICENSE file for details. ",
    "url": "/hf-pcal95555-driver/development/#license",
    
    "relUrl": "/#license"
  },"50": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "HardFOC PCAL95555 Driver",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/",
    
    "relUrl": "/"
  },"51": {
    "doc": "üìñ API Reference",
    "title": "API Reference",
    "content": "Complete reference documentation for all public methods and types in the PCAL95555 driver. ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#api-reference",
    
    "relUrl": "/docs/api_reference/#api-reference"
  },"52": {
    "doc": "üìñ API Reference",
    "title": "Source Code",
    "content": ". | Main Header: inc/pcal95555.hpp | Kconfig Macros: inc/pcal95555_kconfig.hpp (compile-time configuration, included by main header) | Implementation: src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#source-code",
    
    "relUrl": "/docs/api_reference/#source-code"
  },"53": {
    "doc": "üìñ API Reference",
    "title": "Core Class",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#core-class",
    
    "relUrl": "/docs/api_reference/#core-class"
  },"54": {
    "doc": "üìñ API Reference",
    "title": "PCAL95555&lt;I2cType&gt;",
    "content": "Main driver class for interfacing with the PCA9555 and PCAL9555A I/O expanders. The chip variant is auto-detected during initialization. PCAL9555A-specific features (pull resistors, drive strength, input latch, interrupt mask/status, output mode) return false and set Error::UnsupportedFeature when a standard PCA9555 is detected. Template Parameter: I2cType - Your I2C interface implementation (must inherit from pcal95555::I2cInterface&lt;I2cType&gt;) . Location: inc/pcal95555.hpp . Constructors: . Constructor 1: Using address pin levels . | 1 2 . | PCAL95555(I2cType* bus, bool a0_level, bool a1_level, bool a2_level, ChipVariant variant = ChipVariant::Unknown); . | . Parameters: . | bus: Pointer to your I2C interface implementation | a0_level: Initial state of A0 pin (true = HIGH/VDD, false = LOW/GND) | a1_level: Initial state of A1 pin (true = HIGH/VDD, false = LOW/GND) | a2_level: Initial state of A2 pin (true = HIGH/VDD, false = LOW/GND) | variant: Optional chip variant override. Default ChipVariant::Unknown enables auto-detection. Set to ChipVariant::PCA9555 or ChipVariant::PCAL9555A to skip detection. | . Constructor 2: Using I2C address directly . | 1 2 . | explicit PCAL95555(I2cType* bus, uint8_t address, ChipVariant variant = ChipVariant::Unknown); . | . Parameters: . | bus: Pointer to your I2C interface implementation | address: 7-bit I2C address (0x20 to 0x27). Address bits are calculated automatically. | variant: Optional chip variant override (same as above). | . Description: Both constructors use lazy initialization ‚Äì no I2C traffic occurs in the constructor. Initialization (including chip variant detection) happens on first method call or explicit EnsureInitialized(). The address is calculated from A0-A2 levels or used directly. SetAddressPins() is called if supported by the I2C interface. Examples: . | 1 2 3 4 5 6 7 8 9 10 11 . | // Using pin levels - auto-detect chip variant (default) PCAL95555 driver1(bus, false, false, false); // Using address directly - auto-detect PCAL95555 driver2(bus, 0x20); // Force PCA9555 mode (skip Agile I/O detection probe) PCAL95555 driver3(bus, 0x20, ChipVariant::PCA9555); // Force PCAL9555A mode PCAL95555 driver4(bus, false, false, false, ChipVariant::PCAL9555A); . | . Location: inc/pcal95555.hpp . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#pcal95555i2ctype",
    
    "relUrl": "/docs/api_reference/#pcal95555i2ctype"
  },"55": {
    "doc": "üìñ API Reference",
    "title": "Methods",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#methods",
    
    "relUrl": "/docs/api_reference/#methods"
  },"56": {
    "doc": "üìñ API Reference",
    "title": "Initialization",
    "content": "| Method | Signature | Location | . | EnsureInitialized() | bool EnsureInitialized() | src/pcal95555.ipp | . | ResetToDefault() | void ResetToDefault() | src/pcal95555.ipp | . | InitFromConfig() | void InitFromConfig() | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#initialization",
    
    "relUrl": "/docs/api_reference/#initialization"
  },"57": {
    "doc": "üìñ API Reference",
    "title": "Pin Direction",
    "content": "| Method | Signature | Location | . | SetPinDirection() | bool SetPinDirection(uint16_t pin, GPIODir dir) | src/pcal95555.ipp | . | SetDirections() | bool SetDirections(std::initializer_list&lt;std::pair&lt;uint16_t, GPIODir&gt;&gt; configs) | src/pcal95555.ipp | . | SetMultipleDirections() | bool SetMultipleDirections(uint16_t mask, GPIODir dir) | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#pin-direction",
    
    "relUrl": "/docs/api_reference/#pin-direction"
  },"58": {
    "doc": "üìñ API Reference",
    "title": "Pin I/O",
    "content": "| Method | Signature | Location | . | ReadPin() | bool ReadPin(uint16_t pin) | src/pcal95555.ipp | . | ReadPins() | std::vector&lt;std::pair&lt;uint16_t, bool&gt;&gt; ReadPins(std::initializer_list&lt;uint16_t&gt; pins) | src/pcal95555.ipp | . | WritePin() | bool WritePin(uint16_t pin, bool value) | src/pcal95555.ipp | . | WritePins() | bool WritePins(std::initializer_list&lt;std::pair&lt;uint16_t, bool&gt;&gt; configs) | src/pcal95555.ipp | . | TogglePin() | bool TogglePin(uint16_t pin) | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#pin-io",
    
    "relUrl": "/docs/api_reference/#pin-io"
  },"59": {
    "doc": "üìñ API Reference",
    "title": "Pull-up/Pull-down (PCAL9555A only)",
    "content": "Note: These methods return false and set Error::UnsupportedFeature on PCA9555. | Method | Signature | Location | . | SetPullEnable() | bool SetPullEnable(uint16_t pin, bool enable) | src/pcal95555.ipp | . | SetPullEnables() | bool SetPullEnables(std::initializer_list&lt;std::pair&lt;uint16_t, bool&gt;&gt; configs) | src/pcal95555.ipp | . | SetPullDirection() | bool SetPullDirection(uint16_t pin, bool pull_up) | src/pcal95555.ipp | . | SetPullDirections() | bool SetPullDirections(std::initializer_list&lt;std::pair&lt;uint16_t, bool&gt;&gt; configs) | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#pull-uppull-down-pcal9555a-only",
    
    "relUrl": "/docs/api_reference/#pull-uppull-down-pcal9555a-only"
  },"60": {
    "doc": "üìñ API Reference",
    "title": "Drive Strength (PCAL9555A only)",
    "content": "Note: These methods return false and set Error::UnsupportedFeature on PCA9555. | Method | Signature | Location | . | SetDriveStrength() | bool SetDriveStrength(uint16_t pin, DriveStrength level) | src/pcal95555.ipp | . | SetDriveStrengths() | bool SetDriveStrengths(std::initializer_list&lt;std::pair&lt;uint16_t, DriveStrength&gt;&gt; configs) | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#drive-strength-pcal9555a-only",
    
    "relUrl": "/docs/api_reference/#drive-strength-pcal9555a-only"
  },"61": {
    "doc": "üìñ API Reference",
    "title": "Interrupts",
    "content": "Note: ConfigureInterrupt, ConfigureInterrupts, ConfigureInterruptMask, and GetInterruptStatus require PCAL9555A and return false/0 with Error::UnsupportedFeature on PCA9555. The remaining interrupt methods (callbacks, handler) work on both variants ‚Äì on PCA9555, HandleInterrupt() uses change-detection (comparing current vs. previous pin states) instead of the hardware interrupt status register. | Method | Signature | PCAL9555A? | Location | . | ConfigureInterrupt() | bool ConfigureInterrupt(uint16_t pin, InterruptState state) | Yes | src/pcal95555.ipp | . | ConfigureInterrupts() | bool ConfigureInterrupts(std::initializer_list&lt;std::pair&lt;uint16_t, InterruptState&gt;&gt; configs) | Yes | src/pcal95555.ipp | . | ConfigureInterruptMask() | bool ConfigureInterruptMask(uint16_t mask) | Yes | src/pcal95555.ipp | . | GetInterruptStatus() | uint16_t GetInterruptStatus() | Yes | src/pcal95555.ipp | . | RegisterPinInterrupt() | bool RegisterPinInterrupt(uint16_t pin, InterruptEdge edge, std::function&lt;void(uint16_t, bool)&gt; callback) | No | src/pcal95555.ipp | . | UnregisterPinInterrupt() | bool UnregisterPinInterrupt(uint16_t pin) | No | src/pcal95555.ipp | . | SetInterruptCallback() | void SetInterruptCallback(const std::function&lt;void(uint16_t)&gt;&amp; callback) | No | src/pcal95555.ipp | . | RegisterInterruptHandler() | bool RegisterInterruptHandler() | No | src/pcal95555.ipp | . | HandleInterrupt() | void HandleInterrupt() | No | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#interrupts",
    
    "relUrl": "/docs/api_reference/#interrupts"
  },"62": {
    "doc": "üìñ API Reference",
    "title": "Output Mode (PCAL9555A only)",
    "content": "Note: Returns false and sets Error::UnsupportedFeature on PCA9555. | Method | Signature | Location | . | SetOutputMode() | bool SetOutputMode(bool port_0_open_drain, bool port_1_open_drain) | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#output-mode-pcal9555a-only",
    
    "relUrl": "/docs/api_reference/#output-mode-pcal9555a-only"
  },"63": {
    "doc": "üìñ API Reference",
    "title": "Polarity",
    "content": "| Method | Signature | Location | . | SetPinPolarity() | bool SetPinPolarity(uint16_t pin, Polarity polarity) | src/pcal95555.ipp | . | SetPolarities() | bool SetPolarities(std::initializer_list&lt;std::pair&lt;uint16_t, Polarity&gt;&gt; configs) | src/pcal95555.ipp | . | SetMultiplePolarities() | bool SetMultiplePolarities(uint16_t mask, Polarity polarity) | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#polarity",
    
    "relUrl": "/docs/api_reference/#polarity"
  },"64": {
    "doc": "üìñ API Reference",
    "title": "Input Latch (PCAL9555A only)",
    "content": "Note: These methods return false and set Error::UnsupportedFeature on PCA9555. | Method | Signature | Location | . | EnableInputLatch() | bool EnableInputLatch(uint16_t pin, bool enable) | src/pcal95555.ipp | . | EnableInputLatches() | bool EnableInputLatches(std::initializer_list&lt;std::pair&lt;uint16_t, bool&gt;&gt; configs) | src/pcal95555.ipp | . | EnableMultipleInputLatches() | bool EnableMultipleInputLatches(uint16_t mask, bool enable) | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#input-latch-pcal9555a-only",
    
    "relUrl": "/docs/api_reference/#input-latch-pcal9555a-only"
  },"65": {
    "doc": "üìñ API Reference",
    "title": "Address Management",
    "content": "| Method | Signature | Location | . | GetAddress() | uint8_t GetAddress() const | src/pcal95555.ipp | . | GetAddressBits() | uint8_t GetAddressBits() const | src/pcal95555.ipp | . | ChangeAddress() | bool ChangeAddress(bool a0_level, bool a1_level, bool a2_level) | src/pcal95555.ipp | . | ChangeAddress() | bool ChangeAddress(uint8_t address) | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#address-management",
    
    "relUrl": "/docs/api_reference/#address-management"
  },"66": {
    "doc": "üìñ API Reference",
    "title": "Error Handling",
    "content": "| Method | Signature | Location | . | SetRetries() | void SetRetries(int retries) noexcept | src/pcal95555.ipp | . | GetErrorFlags() | [[nodiscard]] uint16_t GetErrorFlags() const noexcept | src/pcal95555.ipp | . | ClearErrorFlags() | void ClearErrorFlags(uint16_t mask = 0xFFFF) noexcept | src/pcal95555.ipp | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#error-handling",
    
    "relUrl": "/docs/api_reference/#error-handling"
  },"67": {
    "doc": "üìñ API Reference",
    "title": "Chip Variant Detection",
    "content": "| Method | Signature | Description | Location | . | HasAgileIO() | [[nodiscard]] bool HasAgileIO() const noexcept | Returns true if PCAL9555A detected (Agile I/O available) | src/pcal95555.ipp | . | GetChipVariant() | [[nodiscard]] ChipVariant GetChipVariant() const noexcept | Returns the detected ChipVariant enum value | src/pcal95555.ipp | . Usage: . | 1 2 3 4 5 6 7 8 9 . | if (driver.HasAgileIO()) { // PCAL9555A features available driver.SetDriveStrength(0, DriveStrength::Level2); } else { // PCA9555 -- only standard registers } auto variant = driver.GetChipVariant(); // ChipVariant::Unknown, ChipVariant::PCA9555, or ChipVariant::PCAL9555A . | . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#chip-variant-detection",
    
    "relUrl": "/docs/api_reference/#chip-variant-detection"
  },"68": {
    "doc": "üìñ API Reference",
    "title": "Types",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#types",
    
    "relUrl": "/docs/api_reference/#types"
  },"69": {
    "doc": "üìñ API Reference",
    "title": "Enumerations",
    "content": "| Type | Values | Description | Location | . | GPIODir | Input, Output | GPIO pin direction | inc/pcal95555.hpp | . | DriveStrength | Level0, Level1, Level2, Level3 | Output drive strength (Level0=25%, Level1=50%, Level2=75%, Level3=100%). PCAL9555A only. | inc/pcal95555.hpp | . | Polarity | Normal, Inverted | Input polarity inversion | inc/pcal95555.hpp | . | OutputMode | PushPull, OpenDrain | Output mode (per port). PCAL9555A only. | inc/pcal95555.hpp | . | InterruptState | Enabled, Disabled | Interrupt enable/disable state. PCAL9555A only. | inc/pcal95555.hpp | . | InterruptEdge | Rising, Falling, Both | Interrupt edge trigger type (works on both variants via software) | inc/pcal95555.hpp | . | ChipVariant | Unknown, PCA9555, PCAL9555A | Detected or user-specified chip variant | inc/pcal95555.hpp | . | Error | None, InvalidPin, InvalidMask, I2CReadFail, I2CWriteFail, UnsupportedFeature, InvalidAddress | Error conditions (bitmask). UnsupportedFeature (0x0010) is set when a PCAL9555A-only method is called on a PCA9555. InvalidAddress (0x0020) is set when an I2C address outside the valid 0x20-0x27 range is provided. | inc/pcal95555.hpp | . Navigation ‚¨ÖÔ∏è Configuration | Next: Examples ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/#enumerations",
    
    "relUrl": "/docs/api_reference/#enumerations"
  },"70": {
    "doc": "üìñ API Reference",
    "title": "üìñ API Reference",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference/",
    
    "relUrl": "/docs/api_reference/"
  },"71": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Configuration",
    "content": "This guide covers all configuration options available for the PCAL95555 driver. ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#configuration",
    
    "relUrl": "/docs/configuration/#configuration"
  },"72": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "I2C Address Configuration",
    "content": "The PCA9555 / PCAL9555A I2C address is configured via hardware pins A0-A2. Each pin represents one bit of the 3-bit address field. Both chip variants use the same address scheme. | Pin | Address Bit | Description | . | A0 | Bit 0 | Least significant address bit | . | A1 | Bit 1 | ¬† | . | A2 | Bit 2 | Most significant address bit | . Default I2C address: 0x20 (all address pins to GND) . Address Range: 0x20 to 0x27 (7-bit I2C addresses) . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#i2c-address-configuration",
    
    "relUrl": "/docs/configuration/#i2c-address-configuration"
  },"73": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Address Pin Configuration Table",
    "content": "| A2 | A1 | A0 | I2C Address (7-bit) | Constructor Call | . | LOW | LOW | LOW | 0x20 (default) | PCAL95555(bus, false, false, false) | . | LOW | LOW | HIGH | 0x21 | PCAL95555(bus, true, false, false) | . | LOW | HIGH | LOW | 0x22 | PCAL95555(bus, false, true, false) | . | LOW | HIGH | HIGH | 0x23 | PCAL95555(bus, true, true, false) | . | HIGH | LOW | LOW | 0x24 | PCAL95555(bus, false, false, true) | . | HIGH | LOW | HIGH | 0x25 | PCAL95555(bus, true, false, true) | . | HIGH | HIGH | LOW | 0x26 | PCAL95555(bus, false, true, true) | . | HIGH | HIGH | HIGH | 0x27 | PCAL95555(bus, true, true, true) | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#address-pin-configuration-table",
    
    "relUrl": "/docs/configuration/#address-pin-configuration-table"
  },"74": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Dynamic Address Changes",
    "content": "If your I2C interface supports GPIO control of address pins (via SetAddressPins()), you can change the address dynamically: . Option 1: Using address directly (recommended) . | 1 2 3 4 5 6 7 8 9 . | // Change address to 0x21 if (gpio.ChangeAddress(0x21)) { printf(\"Address changed to 0x%02X\\n\", gpio.GetAddress()); // 0x21 } // Change address to 0x25 if (gpio.ChangeAddress(0x25)) { printf(\"Address changed to 0x%02X\\n\", gpio.GetAddress()); // 0x25 } . | . Option 2: Using pin levels . | 1 2 3 4 . | // Change address to 0x21 (A0=HIGH, A1=LOW, A2=LOW) if (gpio.ChangeAddress(true, false, false)) { printf(\"Address changed to 0x%02X\\n\", gpio.GetAddress()); // 0x21 } . | . Get current address and address bits: . | 1 2 . | uint8_t addr = gpio.GetAddress(); // Returns current address (e.g., 0x21) uint8_t bits = gpio.GetAddressBits(); // Returns address bits (e.g., 1 = binary 001) . | . Note: Dynamic address changes require hardware support. If address pins are hardwired, ChangeAddress() will still update internal state but won‚Äôt change hardware pins. ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#dynamic-address-changes",
    
    "relUrl": "/docs/configuration/#dynamic-address-changes"
  },"75": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Kconfig Configuration (Optional)",
    "content": "If your project uses Kconfig (e.g., ESP-IDF), the driver supports compile-time configuration. The Kconfig compile-time macros are defined in a dedicated header: inc/pcal95555_kconfig.hpp. This file is automatically included by the main pcal95555.hpp header ‚Äì no additional includes are needed. Kconfig file: Kconfig . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#kconfig-configuration-optional",
    
    "relUrl": "/docs/configuration/#kconfig-configuration-optional"
  },"76": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Configuration Options",
    "content": ". | Per-pin direction: Configure each pin as input (1) or output (0) | Per-pin pull-up/pull-down: Enable pull resistors and select direction | Per-pin initial output: Set initial output state | Port open-drain: Configure ports for open-drain or push-pull mode | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#configuration-options",
    
    "relUrl": "/docs/configuration/#configuration-options"
  },"77": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Using Kconfig",
    "content": ". | Run idf.py menuconfig (or your Kconfig tool) | Navigate to component configuration | Configure per-pin settings as needed | Use InitFromConfig() to apply settings: | . | 1 . | gpio.InitFromConfig(); // Apply Kconfig settings . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#using-kconfig",
    
    "relUrl": "/docs/configuration/#using-kconfig"
  },"78": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Runtime Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#runtime-configuration",
    
    "relUrl": "/docs/configuration/#runtime-configuration"
  },"79": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Pin Direction",
    "content": "Set individual pin direction: . | 1 2 3 4 5 6 7 8 . | // Set pin 0 as output gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); // Set pin 1 as input gpio.SetPinDirection(1, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); // Set multiple pins at once gpio.SetMultipleDirections(0x000F, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); // Pins 0-3 . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#pin-direction",
    
    "relUrl": "/docs/configuration/#pin-direction"
  },"80": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Pull Resistors (PCAL9555A only)",
    "content": "Note: These features require the PCAL9555A. On a standard PCA9555, these methods return false and set Error::UnsupportedFeature. Check with HasAgileIO() first. | 1 2 3 4 5 6 7 8 9 . | if (gpio.HasAgileIO()) { // Enable pull-up on pin 0 gpio.SetPullEnable(0, true); gpio.SetPullDirection(0, true); // true = pull-up, false = pull-down // Enable pull-down on pin 1 gpio.SetPullEnable(1, true); gpio.SetPullDirection(1, false); } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#pull-resistors-pcal9555a-only",
    
    "relUrl": "/docs/configuration/#pull-resistors-pcal9555a-only"
  },"81": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Drive Strength (PCAL9555A only)",
    "content": "Note: Requires PCAL9555A. Returns false with Error::UnsupportedFeature on PCA9555. | 1 . | gpio.SetDriveStrength(0, pcal95555::PCAL95555&lt;MyI2c&gt;::DriveStrength::Level3); // Full strength . | . Drive Strength Levels: . | Level0: 25% drive strength (¬º) | Level1: 50% drive strength (¬Ω) | Level2: 75% drive strength (¬æ) | Level3: 100% drive strength (full) | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#drive-strength-pcal9555a-only",
    
    "relUrl": "/docs/configuration/#drive-strength-pcal9555a-only"
  },"82": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Output Mode (PCAL9555A only)",
    "content": "Note: Requires PCAL9555A. Returns false with Error::UnsupportedFeature on PCA9555. | 1 2 . | // Set PORT_0 to open-drain, PORT_1 to push-pull gpio.SetOutputMode(true, false); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#output-mode-pcal9555a-only",
    
    "relUrl": "/docs/configuration/#output-mode-pcal9555a-only"
  },"83": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Polarity Inversion",
    "content": "Invert input polarity: . | 1 2 3 4 5 . | // Invert pin 0 polarity gpio.SetPinPolarity(0, pcal95555::PCAL95555&lt;MyI2c&gt;::Polarity::Inverted); // Invert multiple pins gpio.SetMultiplePolarities(0x00FF, pcal95555::PCAL95555&lt;MyI2c&gt;::Polarity::Inverted); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#polarity-inversion",
    
    "relUrl": "/docs/configuration/#polarity-inversion"
  },"84": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Default Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#default-configuration",
    
    "relUrl": "/docs/configuration/#default-configuration"
  },"85": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "ResetToDefault()",
    "content": "Resets all registers to power-on defaults: . | 1 . | gpio.ResetToDefault(); . | . Default State: . | All pins: Inputs with pull-ups enabled | Drive strength: Full | Output mode: Push-pull | Interrupts: Masked (disabled) | Polarity: Normal (not inverted) | . Location: src/pcal95555.ipp . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#resettodefault",
    
    "relUrl": "/docs/configuration/#resettodefault"
  },"86": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Chip Variant Configuration",
    "content": "The driver auto-detects the chip variant (PCA9555 vs PCAL9555A) during initialization. You can also force a specific variant via the constructor to skip the detection probe: . | 1 2 3 4 5 6 7 8 . | // Auto-detect (default) pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); // Force PCA9555 mode (skips Agile I/O probe -- avoids NACK on known PCA9555) pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20, pcal95555::ChipVariant::PCA9555); // Force PCAL9555A mode pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20, pcal95555::ChipVariant::PCAL9555A); . | . Query the detected variant at runtime: . | 1 2 3 4 5 . | if (gpio.HasAgileIO()) { // PCAL9555A features available } auto variant = gpio.GetChipVariant(); // ChipVariant::Unknown, ChipVariant::PCA9555, or ChipVariant::PCAL9555A . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#chip-variant-configuration",
    
    "relUrl": "/docs/configuration/#chip-variant-configuration"
  },"87": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Interrupt Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#interrupt-configuration",
    
    "relUrl": "/docs/configuration/#interrupt-configuration"
  },"88": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Basic Interrupt Setup",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 . | // Enable interrupt on pin 5 (recommended method) gpio.ConfigureInterrupt(5, InterruptState::Enabled); // Disable interrupt on pin 3 gpio.ConfigureInterrupt(3, InterruptState::Disabled); // Configure multiple pins at once gpio.ConfigureInterrupts({ {0, InterruptState::Enabled}, {5, InterruptState::Enabled}, {10, InterruptState::Enabled}, {3, InterruptState::Disabled} }); // Set global interrupt callback (optional) gpio.SetInterruptCallback([](uint16_t status) { printf(\"Interrupt on pins: 0x%04X\\n\", status); }); // Handle interrupt (call from ISR or polling) gpio.HandleInterrupt(); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#basic-interrupt-setup",
    
    "relUrl": "/docs/configuration/#basic-interrupt-setup"
  },"89": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Per-Pin Interrupt Callbacks",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | // Register callback for specific pin with edge detection gpio.RegisterPinInterrupt(5, InterruptEdge::Rising, [](uint16_t pin, bool state) { printf(\"Pin %d went HIGH\\n\", pin); }); // Register callback for falling edge gpio.RegisterPinInterrupt(3, InterruptEdge::Falling, [](uint16_t pin, bool state) { printf(\"Pin %d went LOW\\n\", pin); }); // Register callback for both edges gpio.RegisterPinInterrupt(7, InterruptEdge::Both, [](uint16_t pin, bool state) { printf(\"Pin %d changed to %s\\n\", pin, state ? \"HIGH\" : \"LOW\"); }); // Register interrupt handler with I2C interface (for hardware interrupts) gpio.RegisterInterruptHandler(); // Sets up INT pin handling . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#per-pin-interrupt-callbacks",
    
    "relUrl": "/docs/configuration/#per-pin-interrupt-callbacks"
  },"90": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Get Interrupt Status",
    "content": "| 1 2 3 . | uint16_t status = gpio.GetInterruptStatus(); // Check which pins triggered interrupt // Reading this register clears the interrupt condition . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#get-interrupt-status",
    
    "relUrl": "/docs/configuration/#get-interrupt-status"
  },"91": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Recommended Settings",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#recommended-settings",
    
    "relUrl": "/docs/configuration/#recommended-settings"
  },"92": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Input Pins",
    "content": "| 1 2 3 . | gpio.SetPinDirection(pin, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); gpio.SetPullEnable(pin, true); gpio.SetPullDirection(pin, true); // Pull-up . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#for-input-pins",
    
    "relUrl": "/docs/configuration/#for-input-pins"
  },"93": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Output Pins",
    "content": "| 1 2 3 . | gpio.SetPinDirection(pin, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.SetDriveStrength(pin, pcal95555::PCAL95555&lt;MyI2c&gt;::DriveStrength::Level3); // Full strength gpio.WritePin(pin, false); // Set initial state . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#for-output-pins",
    
    "relUrl": "/docs/configuration/#for-output-pins"
  },"94": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Interrupt-Driven Inputs",
    "content": "| 1 2 3 4 5 . | gpio.SetPinDirection(pin, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); gpio.SetPullEnable(pin, true); gpio.SetPullDirection(pin, true); gpio.EnableInputLatch(pin, true); // Latch input changes gpio.ConfigureInterrupt(pin, InterruptState::Enabled); // Enable interrupt for this pin . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#for-interrupt-driven-inputs",
    
    "relUrl": "/docs/configuration/#for-interrupt-driven-inputs"
  },"95": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Next Steps",
    "content": ". | See Examples for configuration examples | Review API Reference for all configuration methods | . Navigation ‚¨ÖÔ∏è Platform Integration | Next: API Reference ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#next-steps",
    
    "relUrl": "/docs/configuration/#next-steps"
  },"96": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "‚öôÔ∏è Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/",
    
    "relUrl": "/docs/configuration/"
  },"97": {
    "doc": "üí° Examples",
    "title": "Examples",
    "content": "This guide provides complete, working examples demonstrating various use cases for the PCAL95555 driver. ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#examples",
    
    "relUrl": "/docs/examples/#examples"
  },"98": {
    "doc": "üí° Examples",
    "title": "Example 1: Basic GPIO Control",
    "content": "This example shows basic input/output operations. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . | #include \"pcal95555.hpp\" // Implement I2C interface (see platform_integration.md) class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { // ... implement Write() and Read() }; MyI2c i2c; // Option 1: Using address directly (recommended) pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); // Address 0x20 (default) // Option 2: Using pin levels // pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, false, false, false); void app_main(void) { // Initialize driver (lazy initialization happens automatically, but explicit is clearer) if (!gpio.EnsureInitialized()) { ESP_LOGE(\"APP\", \"Failed to initialize PCAL95555\"); return; } gpio.ResetToDefault(); // Configure pin 0 as output gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.WritePin(0, true); // Configure pin 1 as input gpio.SetPinDirection(1, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); bool value = gpio.ReadPin(1); } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-1-basic-gpio-control",
    
    "relUrl": "/docs/examples/#example-1-basic-gpio-control"
  },"99": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": ". | Reset: Put device in known state | Configure: Set pin directions | Use: Read and write pin states | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#explanation",
    
    "relUrl": "/docs/examples/#explanation"
  },"100": {
    "doc": "üí° Examples",
    "title": "Example 2: Multiple Pins Configuration",
    "content": "This example demonstrates configuring multiple pins at once with individual settings. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 . | // Configure multiple pins with individual directions gpio.SetDirections({ {0, GPIODir::Output}, {1, GPIODir::Input}, {5, GPIODir::Output}, {10, GPIODir::Input} }); // Write to multiple pins at once gpio.WritePins({ {0, true}, {5, false}, {10, true} }); // Read multiple pins at once auto results = gpio.ReadPins({0, 1, 5, 10}); for (const auto&amp; [pin, value] : results) { printf(\"Pin %d: %s\\n\", pin, value ? \"HIGH\" : \"LOW\"); } // Configure pull resistors for multiple pins gpio.SetPullEnables({ {1, true}, // Enable pull on pin 1 {10, true} // Enable pull on pin 10 }); gpio.SetPullDirections({ {1, true}, // Pull-up on pin 1 {10, false} // Pull-down on pin 10 }); // Configure drive strength for multiple pins gpio.SetDriveStrengths({ {0, DriveStrength::Level3}, // Full strength {5, DriveStrength::Level1} // 50% strength }); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-2-multiple-pins-configuration",
    
    "relUrl": "/docs/examples/#example-2-multiple-pins-configuration"
  },"101": {
    "doc": "üí° Examples",
    "title": "Example 3: Interrupt Handling",
    "content": "This example shows how to use interrupts with per-pin callbacks. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . | // Configure pin 8 as input with interrupt gpio.SetPinDirection(8, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); gpio.SetPullEnable(8, true); gpio.SetPullDirection(8, true); // Pull-up gpio.EnableInputLatch(8, true); gpio.ConfigureInterrupt(8, InterruptState::Enabled); // Enable interrupt // Register per-pin callback for rising edge gpio.RegisterPinInterrupt(8, InterruptEdge::Rising, [](uint16_t pin, bool state) { printf(\"Pin %d interrupt: went HIGH\\n\", pin); }); // Register interrupt handler with I2C interface (for hardware INT pin) gpio.RegisterInterruptHandler(); // Sets up INT pin handling // In your main loop or ISR (if using polling) gpio.HandleInterrupt(); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-3-interrupt-handling",
    
    "relUrl": "/docs/examples/#example-3-interrupt-handling"
  },"102": {
    "doc": "üí° Examples",
    "title": "Configure Multiple Interrupts",
    "content": "| 1 2 3 4 5 6 7 . | // Configure interrupts for multiple pins at once gpio.ConfigureInterrupts({ {0, InterruptState::Enabled}, // Enable on pin 0 {5, InterruptState::Enabled}, // Enable on pin 5 {10, InterruptState::Enabled}, // Enable on pin 10 {3, InterruptState::Disabled} // Disable on pin 3 }); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#configure-multiple-interrupts",
    
    "relUrl": "/docs/examples/#configure-multiple-interrupts"
  },"103": {
    "doc": "üí° Examples",
    "title": "Global Interrupt Callback",
    "content": "| 1 2 3 4 5 . | // Set global callback for all interrupts gpio.SetInterruptCallback([](uint16_t status) { printf(\"Interrupt on pins: 0x%04X\\n\", status); // Handle interrupt }); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#global-interrupt-callback",
    
    "relUrl": "/docs/examples/#global-interrupt-callback"
  },"104": {
    "doc": "üí° Examples",
    "title": "Example 4: Pull Resistors (PCAL9555A only)",
    "content": "This example demonstrates pull resistor configuration. These methods require the PCAL9555A and return false with Error::UnsupportedFeature on a standard PCA9555. | 1 2 3 4 5 6 7 8 9 . | // Check chip variant first if (!gpio.HasAgileIO()) { printf(\"PCA9555 detected -- pull resistors require external components\\n\"); } else { // Configure pin as input with pull-down gpio.SetPinDirection(5, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); gpio.SetPullEnable(5, true); gpio.SetPullDirection(5, false); // Pull-down } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-4-pull-resistors-pcal9555a-only",
    
    "relUrl": "/docs/examples/#example-4-pull-resistors-pcal9555a-only"
  },"105": {
    "doc": "üí° Examples",
    "title": "Example 5: Drive Strength (PCAL9555A only)",
    "content": "This example shows drive strength configuration. Requires PCAL9555A. | 1 2 3 4 5 . | if (gpio.HasAgileIO()) { // Set pin as output with reduced drive strength gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.SetDriveStrength(0, pcal95555::PCAL95555&lt;MyI2c&gt;::DriveStrength::Level1); // 50% strength } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-5-drive-strength-pcal9555a-only",
    
    "relUrl": "/docs/examples/#example-5-drive-strength-pcal9555a-only"
  },"106": {
    "doc": "üí° Examples",
    "title": "Example 6: Address Management",
    "content": "This example shows how to work with I2C addresses. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 . | // Option 1: Create driver using address directly (recommended) pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x21); // Address 0x21 // Option 2: Create driver using pin levels // pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, true, false, false); // A0=HIGH -&gt; 0x21 // Get current address uint8_t addr = gpio.GetAddress(); // Returns 0x21 uint8_t bits = gpio.GetAddressBits(); // Returns 1 (binary: 001) // Change address dynamically using address value (if I2C interface supports GPIO control) if (gpio.ChangeAddress(0x20)) { printf(\"Address changed to 0x%02X\\n\", gpio.GetAddress()); // Now 0x20 } // Change address using pin levels if (gpio.ChangeAddress(false, false, false)) { printf(\"Address changed to 0x%02X\\n\", gpio.GetAddress()); // Now 0x20 } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-6-address-management",
    
    "relUrl": "/docs/examples/#example-6-address-management"
  },"107": {
    "doc": "üí° Examples",
    "title": "Example 7: Error Handling",
    "content": "This example shows error handling, retry configuration, and UnsupportedFeature detection. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 . | // Configure retry mechanism gpio.SetRetries(3); // Retry up to 3 times on I2C failure // Perform operations gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.WritePin(0, true); // Check for errors uint16_t errors = gpio.GetErrorFlags(); if (errors != 0) { if (errors &amp; static_cast&lt;uint16_t&gt;(Error::I2CReadFail)) { printf(\"I2C read failed\\n\"); } if (errors &amp; static_cast&lt;uint16_t&gt;(Error::I2CWriteFail)) { printf(\"I2C write failed\\n\"); } if (errors &amp; static_cast&lt;uint16_t&gt;(Error::InvalidPin)) { printf(\"Invalid pin number\\n\"); } if (errors &amp; static_cast&lt;uint16_t&gt;(Error::UnsupportedFeature)) { printf(\"Feature requires PCAL9555A (this is a PCA9555)\\n\"); } // Clear all errors gpio.ClearErrorFlags(); // Or clear only specific flags // gpio.ClearErrorFlags(static_cast&lt;uint16_t&gt;(Error::InvalidPin)); } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-7-error-handling",
    
    "relUrl": "/docs/examples/#example-7-error-handling"
  },"108": {
    "doc": "üí° Examples",
    "title": "Example 8: Chip Variant Detection",
    "content": "This example shows how to check which chip is connected and conditionally use features. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 . | // After initialization (auto or explicit) gpio.EnsureInitialized(); // Method 1: Boolean check if (gpio.HasAgileIO()) { printf(\"PCAL9555A detected -- full feature set available\\n\"); gpio.SetPullEnable(0, true); gpio.SetDriveStrength(0, DriveStrength::Level3); } else { printf(\"PCA9555 detected -- standard GPIO only\\n\"); // Use external pull-up resistors instead } // Method 2: Variant enum auto variant = gpio.GetChipVariant(); switch (variant) { case pcal95555::ChipVariant::PCA9555: printf(\"Standard PCA9555\\n\"); break; case pcal95555::ChipVariant::PCAL9555A: printf(\"Enhanced PCAL9555A with Agile I/O\\n\"); break; default: printf(\"Unknown variant (detection may have failed)\\n\"); break; } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-8-chip-variant-detection",
    
    "relUrl": "/docs/examples/#example-8-chip-variant-detection"
  },"109": {
    "doc": "üí° Examples",
    "title": "Running the Examples",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#running-the-examples",
    
    "relUrl": "/docs/examples/#running-the-examples"
  },"110": {
    "doc": "üí° Examples",
    "title": "ESP32",
    "content": "Two example applications are available in examples/esp32: . | 1 2 3 4 5 6 7 8 9 . | cd examples/esp32 # Comprehensive test suite (tests all 43 API methods) ./scripts/build_app.sh pcal95555_comprehensive_test Debug ./scripts/flash_app.sh flash_monitor pcal95555_comprehensive_test Debug # LED animation demo (16-LED patterns) ./scripts/build_app.sh pcal95555_led_animation Debug ./scripts/flash_app.sh flash_monitor pcal95555_led_animation Debug . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#esp32",
    
    "relUrl": "/docs/examples/#esp32"
  },"111": {
    "doc": "üí° Examples",
    "title": "Other Platforms",
    "content": "Adapt the I2C interface implementation for your platform (see Platform Integration) and compile with your platform‚Äôs toolchain. ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#other-platforms",
    
    "relUrl": "/docs/examples/#other-platforms"
  },"112": {
    "doc": "üí° Examples",
    "title": "Next Steps",
    "content": ". | Review the API Reference for method details | Check Troubleshooting if you encounter issues | Explore the examples directory for more examples | . Navigation ‚¨ÖÔ∏è API Reference | Next: Troubleshooting ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#next-steps",
    
    "relUrl": "/docs/examples/#next-steps"
  },"113": {
    "doc": "üí° Examples",
    "title": "üí° Examples",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/examples/",
    
    "relUrl": "/docs/examples/"
  },"114": {
    "doc": "üîå Hardware Setup",
    "title": "Hardware Setup",
    "content": "This guide covers the physical connections and hardware requirements for the PCA9555 and PCAL9555A chips. Both are pin-compatible ‚Äì the same wiring works for either variant. The driver auto-detects which chip is connected. ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#hardware-setup",
    
    "relUrl": "/docs/hardware_setup/#hardware-setup"
  },"115": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Connections",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#pin-connections",
    
    "relUrl": "/docs/hardware_setup/#pin-connections"
  },"116": {
    "doc": "üîå Hardware Setup",
    "title": "Basic I2C Connections",
    "content": "| 1 2 3 4 5 6 . | MCU PCA9555 / PCAL9555A ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GND SCL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCL (with 4.7kŒ© pull-up to 3.3V) SDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDA (with 4.7kŒ© pull-up to 3.3V) . | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#basic-i2c-connections",
    
    "relUrl": "/docs/hardware_setup/#basic-i2c-connections"
  },"117": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Descriptions",
    "content": "| Pin | Name | Description | Required | . | VDD | Power | 1.65V to 5.5V power supply (typically 3.3V) | Yes | . | GND | Ground | Ground reference | Yes | . | SCL | Clock | I2C clock line | Yes | . | SDA | Data | I2C data line | Yes | . | A0-A2 | Address | I2C address selection pins | No (for single device) | . | INT | Interrupt | Interrupt output (optional) | No | . | RESET | Reset | Hardware reset (optional) | No | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#pin-descriptions",
    
    "relUrl": "/docs/hardware_setup/#pin-descriptions"
  },"118": {
    "doc": "üîå Hardware Setup",
    "title": "GPIO Pins",
    "content": "The PCA9555 / PCAL9555A provides 16 GPIO pins organized into two ports: . | PORT_0: Pins 0-7 (P0.0 through P0.7) | PORT_1: Pins 8-15 (P1.0 through P1.7) | . Each pin can be configured as: . | Input or output (PCA9555 + PCAL9555A) | With or without pull-up/pull-down resistor (PCAL9555A only) | Push-pull or open-drain output per port (PCAL9555A only) | Interrupt enabled or disabled (PCAL9555A only; software callbacks work on both) | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#gpio-pins",
    
    "relUrl": "/docs/hardware_setup/#gpio-pins"
  },"119": {
    "doc": "üîå Hardware Setup",
    "title": "Power Requirements",
    "content": ". | Supply Voltage: 1.65V to 5.5V (3.3V typical) | Current Consumption: . | Active: ~100 ¬µA typical | Standby: &lt; 1 ¬µA | . | Power Supply: Stable, low-noise supply recommended | Decoupling: 100 nF ceramic capacitor close to VDD pin recommended | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#power-requirements",
    
    "relUrl": "/docs/hardware_setup/#power-requirements"
  },"120": {
    "doc": "üîå Hardware Setup",
    "title": "I2C Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#i2c-configuration",
    
    "relUrl": "/docs/hardware_setup/#i2c-configuration"
  },"121": {
    "doc": "üîå Hardware Setup",
    "title": "Address Configuration",
    "content": "The I/O expander I2C address is determined by pins A0-A2: . | A2 | A1 | A0 | I2C Address (7-bit) | . | 0 | 0 | 0 | 0x20 (default) | . | 0 | 0 | 1 | 0x21 | . | 0 | 1 | 0 | 0x22 | . | 0 | 1 | 1 | 0x23 | . | 1 | 0 | 0 | 0x24 | . | 1 | 0 | 1 | 0x25 | . | 1 | 1 | 0 | 0x26 | . | 1 | 1 | 1 | 0x27 | . Default: All address pins to GND = 0x20 (used in examples) . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#address-configuration",
    
    "relUrl": "/docs/hardware_setup/#address-configuration"
  },"122": {
    "doc": "üîå Hardware Setup",
    "title": "I2C Bus Configuration",
    "content": ". | Speed: Up to 400 kHz (Fast Mode) . | Standard Mode: 100 kHz | Fast Mode: 400 kHz (most common) | . | Pull-up Resistors: 4.7 kŒ© on SCL and SDA (required for I2C) | Bus Voltage: Must match VDD (typically 3.3V) | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#i2c-bus-configuration",
    
    "relUrl": "/docs/hardware_setup/#i2c-bus-configuration"
  },"123": {
    "doc": "üîå Hardware Setup",
    "title": "Physical Layout Recommendations",
    "content": ". | Trace Length: Keep I2C traces short (&lt; 10 cm recommended) | Ground Plane: Use a ground plane for noise reduction | Decoupling: Place 100 nF ceramic capacitor within 1 cm of VDD pin | Routing: Route clock and data lines away from noise sources | Multiple Devices: When using multiple expanders, use proper bus termination | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#physical-layout-recommendations",
    
    "relUrl": "/docs/hardware_setup/#physical-layout-recommendations"
  },"124": {
    "doc": "üîå Hardware Setup",
    "title": "Example Wiring Diagram",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#example-wiring-diagram",
    
    "relUrl": "/docs/hardware_setup/#example-wiring-diagram"
  },"125": {
    "doc": "üîå Hardware Setup",
    "title": "Single Device",
    "content": "| 1 2 3 4 5 6 7 8 9 10 . | PCA9555 / PCAL9555A ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ VDD ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ GND ‚îÇ SCL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SCL ‚îÇ‚îÄ‚îÄ‚îÄ 4.7kŒ© ‚îÄ‚îÄ‚îÄ 3.3V SDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDA ‚îÇ‚îÄ‚îÄ‚îÄ 4.7kŒ© ‚îÄ‚îÄ‚îÄ 3.3V ‚îÇ ‚îÇ ‚îÇ P0.0-7 ‚îÇ‚îÄ‚îÄ‚îÄ GPIO pins (PORT_0) ‚îÇ P1.0-7 ‚îÇ‚îÄ‚îÄ‚îÄ GPIO pins (PORT_1) ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò . | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#single-device",
    
    "relUrl": "/docs/hardware_setup/#single-device"
  },"126": {
    "doc": "üîå Hardware Setup",
    "title": "Multiple Devices",
    "content": "| 1 2 3 4 5 6 7 . | MCU SCL ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ Device #1 (A0=0, Addr=0x20) SCL ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ Device #2 (A0=1, Addr=0x21) SCL MCU SDA ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ Device #1 SDA ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ Device #2 SDA . | . Note: You can mix PCA9555 and PCAL9555A devices on the same I2C bus. Each driver instance auto-detects its chip variant independently. ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#multiple-devices",
    
    "relUrl": "/docs/hardware_setup/#multiple-devices"
  },"127": {
    "doc": "üîå Hardware Setup",
    "title": "Interrupt Pin (Optional)",
    "content": "The INT pin provides hardware interrupt notification: . | Type: Open-drain output | Requires: External pull-up resistor (typically 10kŒ© to 3.3V) | Usage: Connect to a GPIO input on your MCU for interrupt-driven I/O | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#interrupt-pin-optional",
    
    "relUrl": "/docs/hardware_setup/#interrupt-pin-optional"
  },"128": {
    "doc": "üîå Hardware Setup",
    "title": "Reset Pin (Optional)",
    "content": "The RESET pin provides hardware reset: . | Type: Active-low input | Usage: Connect to MCU GPIO for software reset capability | Default: Leave floating (internal pull-up enables device) | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#reset-pin-optional",
    
    "relUrl": "/docs/hardware_setup/#reset-pin-optional"
  },"129": {
    "doc": "üîå Hardware Setup",
    "title": "Next Steps",
    "content": ". | Verify connections with a multimeter | Use an I2C scanner to verify device detection at expected address | Proceed to Quick Start to test the connection | Review Platform Integration for software setup | . Navigation ‚¨ÖÔ∏è Quick Start | Next: Platform Integration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#next-steps",
    
    "relUrl": "/docs/hardware_setup/#next-steps"
  },"130": {
    "doc": "üîå Hardware Setup",
    "title": "üîå Hardware Setup",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/",
    
    "relUrl": "/docs/hardware_setup/"
  },"131": {
    "doc": "üìö Documentation",
    "title": "HF-PCAL95555 Documentation",
    "content": "Welcome! This directory contains step-by-step guides for installing, building, and using the HF-PCAL95555 library ‚Äì a hardware-agnostic C++ driver for the PCA9555 and PCAL9555A 16-bit I/O expanders. The driver auto-detects which chip variant is connected and enables features accordingly. Standard PCA9555 features work on both chips; PCAL9555A-only features (pull resistors, drive strength, input latch, interrupt mask/status, output mode) degrade gracefully on a PCA9555. ",
    "url": "/hf-pcal95555-driver/development/docs/#hf-pcal95555-documentation",
    
    "relUrl": "/docs/#hf-pcal95555-documentation"
  },"132": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation Structure",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/#-documentation-structure",
    
    "relUrl": "/docs/#-documentation-structure"
  },"133": {
    "doc": "üìö Documentation",
    "title": "Getting Started",
    "content": ". | üõ†Ô∏è Installation ‚Äì How to integrate the driver into your project | ‚ö° Quick Start ‚Äì Minimal working example to get you running | üîå Hardware Setup ‚Äì Wiring diagrams and pin connections | . ",
    "url": "/hf-pcal95555-driver/development/docs/#getting-started",
    
    "relUrl": "/docs/#getting-started"
  },"134": {
    "doc": "üìö Documentation",
    "title": "Integration",
    "content": ". | üîß Platform Integration ‚Äì Implement the CRTP I2C interface for your platform | ‚öôÔ∏è Configuration ‚Äì Configuration options and Kconfig settings | . ",
    "url": "/hf-pcal95555-driver/development/docs/#integration",
    
    "relUrl": "/docs/#integration"
  },"135": {
    "doc": "üìö Documentation",
    "title": "Reference",
    "content": ". | üìñ API Reference ‚Äì Complete API documentation (43 methods) | üí° Examples ‚Äì Detailed example walkthroughs (comprehensive test + LED animation) | . ",
    "url": "/hf-pcal95555-driver/development/docs/#reference",
    
    "relUrl": "/docs/#reference"
  },"136": {
    "doc": "üìö Documentation",
    "title": "Troubleshooting",
    "content": ". | üêõ Troubleshooting ‚Äì Common issues and solutions | . ",
    "url": "/hf-pcal95555-driver/development/docs/#troubleshooting",
    
    "relUrl": "/docs/#troubleshooting"
  },"137": {
    "doc": "üìö Documentation",
    "title": "üöÄ Quick Start Path",
    "content": "New to PCAL95555? Follow this recommended path: . | Start with Installation to integrate the driver | Follow Hardware Setup to wire your I/O expander | Read Quick Start for a minimal working example | Check Platform Integration to implement the I2C interface | Explore Examples for more advanced usage | . ",
    "url": "/hf-pcal95555-driver/development/docs/#-quick-start-path",
    
    "relUrl": "/docs/#-quick-start-path"
  },"138": {
    "doc": "üìö Documentation",
    "title": "üí° Need Help?",
    "content": ". | üêõ Found a bug? Check the Troubleshooting guide | ‚ùì Have questions? Review the API Reference | üìù Want to contribute? See the contributing guidelines in the main README | . Navigation ‚û°Ô∏è Installation . ",
    "url": "/hf-pcal95555-driver/development/docs/#-need-help",
    
    "relUrl": "/docs/#-need-help"
  },"139": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/",
    
    "relUrl": "/docs/"
  },"140": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Installation",
    "content": "This guide covers how to integrate the PCAL95555 driver into your project. ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#installation",
    
    "relUrl": "/docs/installation/#installation"
  },"141": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Prerequisites",
    "content": "Before installing the driver, ensure you have: . | C++17 Compiler: GCC 7+, Clang 5+, or MSVC 2017+ | I2C Interface: Your platform‚Äôs I2C driver (ESP-IDF, STM32 HAL, Arduino Wire, etc.) | Compatible chip: PCA9555 or PCAL9555A (the driver auto-detects which variant is connected) | . ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#prerequisites",
    
    "relUrl": "/docs/installation/#prerequisites"
  },"142": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Integration",
    "content": "This driver is a header-only template library designed to be integrated directly into your project. There‚Äôs no separate build step required. ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#integration",
    
    "relUrl": "/docs/installation/#integration"
  },"143": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 1: Copy Files",
    "content": "Copy the following files into your project: . | 1 2 3 4 5 . | inc/ ‚îú‚îÄ‚îÄ pcal95555.hpp ‚îî‚îÄ‚îÄ pcal95555_kconfig.hpp src/ ‚îî‚îÄ‚îÄ pcal95555.ipp . | . Note: The driver uses a header-only template design where pcal95555.ipp is included by pcal95555.hpp. Kconfig compile-time configuration macros live in pcal95555_kconfig.hpp (also included automatically). You typically only need to include the main header file in your project. ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#option-1-copy-files",
    
    "relUrl": "/docs/installation/#option-1-copy-files"
  },"144": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 2: Git Submodule",
    "content": "| 1 2 . | cd your-project git submodule add https://github.com/N3b3x/hf-pcal95555-driver.git drivers/pcal95555 . | . Then add to your include path: . | 1 . | target_include_directories(your_target PRIVATE drivers/pcal95555/inc) . | . ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#option-2-git-submodule",
    
    "relUrl": "/docs/installation/#option-2-git-submodule"
  },"145": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Including the Header",
    "content": "Simply include the header in your code: . | 1 . | #include \"pcal95555.hpp\" . | . The implementation is included automatically via the header file. ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#including-the-header",
    
    "relUrl": "/docs/installation/#including-the-header"
  },"146": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Next Steps",
    "content": ". | Follow the Quick Start guide to create your first application | Review Hardware Setup for wiring instructions | Check Platform Integration to implement the I2C interface | . Navigation ‚¨ÖÔ∏è Back to Index | Next: Quick Start ‚û°Ô∏è . ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#next-steps",
    
    "relUrl": "/docs/installation/#next-steps"
  },"147": {
    "doc": "üõ†Ô∏è Installation",
    "title": "üõ†Ô∏è Installation",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/installation/",
    
    "relUrl": "/docs/installation/"
  },"148": {
    "doc": "üîß Platform Integration",
    "title": "Platform Integration Guide",
    "content": "This guide explains how to implement the hardware abstraction interface for the PCAL95555 driver on your platform. ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#platform-integration-guide",
    
    "relUrl": "/docs/platform_integration/#platform-integration-guide"
  },"149": {
    "doc": "üîß Platform Integration",
    "title": "Understanding CRTP (Curiously Recurring Template Pattern)",
    "content": "The PCAL95555 driver uses CRTP (Curiously Recurring Template Pattern) for hardware abstraction. This design choice provides several critical benefits for embedded systems: . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern",
    
    "relUrl": "/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern"
  },"150": {
    "doc": "üîß Platform Integration",
    "title": "Why CRTP Instead of Virtual Functions?",
    "content": "1. Zero Runtime Overhead . | Virtual functions: Require a vtable lookup (indirect call) = ~5-10 CPU cycles overhead per call | CRTP: Direct function calls = 0 overhead, compiler can inline | Impact: In time-critical embedded code, this matters significantly | . 2. Compile-Time Polymorphism . | Virtual functions: Runtime dispatch - the compiler cannot optimize across the abstraction boundary | CRTP: Compile-time dispatch - full optimization, dead code elimination, constant propagation | Impact: Smaller code size, faster execution | . 3. Memory Efficiency . | Virtual functions: Each object needs a vtable pointer (4-8 bytes) | CRTP: No vtable pointer needed | Impact: Critical in memory-constrained systems (many MCUs have &lt;64KB RAM) | . 4. Type Safety . | Virtual functions: Runtime errors if method not implemented | CRTP: Compile-time errors if method not implemented | Impact: Catch bugs at compile time, not in the field | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#why-crtp-instead-of-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#why-crtp-instead-of-virtual-functions"
  },"151": {
    "doc": "üîß Platform Integration",
    "title": "How CRTP Works",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 . | // Base template class (from pcal95555_i2c_interface.hpp) template &lt;typename Derived&gt; class I2cInterface { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // Cast 'this' to Derived* and call the derived implementation return static_cast&lt;Derived*&gt;(this)-&gt;Write(addr, reg, data, len); } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { return static_cast&lt;Derived*&gt;(this)-&gt;Read(addr, reg, data, len); } }; // Your implementation class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: // This method is called directly (no virtual overhead) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // Your platform-specific I2C code } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { // Your platform-specific I2C code } }; . | . The key insight: static_cast&lt;Derived*&gt;(this) allows the base class to call methods on the derived class at compile time, not runtime. ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#how-crtp-works",
    
    "relUrl": "/docs/platform_integration/#how-crtp-works"
  },"152": {
    "doc": "üîß Platform Integration",
    "title": "Performance Comparison",
    "content": "| Aspect | Virtual Functions | CRTP | . | Function call overhead | ~5-10 cycles | 0 cycles (inlined) | . | Code size | Larger (vtables) | Smaller (optimized) | . | Memory per object | +4-8 bytes (vptr) | 0 bytes | . | Compile-time checks | No | Yes | . | Optimization | Limited | Full | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#performance-comparison",
    
    "relUrl": "/docs/platform_integration/#performance-comparison"
  },"153": {
    "doc": "üîß Platform Integration",
    "title": "Interface Definition",
    "content": "The PCAL95555 driver requires you to implement the I2cInterface template: . Location: inc/pcal95555.hpp#L437 . | 1 2 3 4 5 6 7 . | template &lt;typename Derived&gt; class I2cInterface { public: // Required methods (implement both) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len); bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len); }; . | . Required Methods (must be implemented): . | Write(): Write len bytes from data to register reg at I2C address addr (7-bit address) | Read(): Read len bytes into data from register reg at I2C address addr (7-bit address) | EnsureInitialized(): Ensure I2C bus is initialized and ready for communication | All return true on success, false on failure (NACK, timeout, etc.) | . Optional Methods (can be overridden for additional functionality): . | SetAddressPins(): Control A2-A0 address pins via GPIO (returns false by default if not supported) | RegisterInterruptHandler(): Register interrupt handler for INT pin (returns false by default if not supported) | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#interface-definition",
    
    "relUrl": "/docs/platform_integration/#interface-definition"
  },"154": {
    "doc": "üîß Platform Integration",
    "title": "Implementation Steps",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#implementation-steps",
    
    "relUrl": "/docs/platform_integration/#implementation-steps"
  },"155": {
    "doc": "üîß Platform Integration",
    "title": "Step 1: Create Your Implementation Class",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 . | #include \"pcal95555.hpp\" class MyPlatformI2c : public pcal95555::I2cInterface&lt;MyPlatformI2c&gt; { private: // Your platform-specific members i2c_handle_t i2c_handle_; public: // Constructor MyPlatformI2c(i2c_handle_t handle) : i2c_handle_(handle) {} // Implement required methods (NO virtual keyword!) bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // Your I2C write implementation return true; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { // Your I2C read implementation return true; } // Required: Ensure I2C bus is initialized and ready bool EnsureInitialized() { if (initialized_) { return true; // Already initialized } // Initialize I2C hardware, configure pins, set up bus, etc. // ... initialized_ = true; return true; } // Optional: Override to support dynamic address pin control bool SetAddressPins(bool a0_level, bool a1_level, bool a2_level) { // Set GPIO pins connected to A2-A0 address pins // Return true if supported, false if not supported (hardwired) return false; // Default: not supported } // Optional: Override to support hardware interrupt handling bool RegisterInterruptHandler(std::function&lt;void()&gt; handler) { // Set up GPIO interrupt for INT pin // Call handler() when INT pin fires // Return true if supported, false if not supported return false; // Default: not supported } private: bool initialized_ = false; // Track initialization state }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#step-1-create-your-implementation-class",
    
    "relUrl": "/docs/platform_integration/#step-1-create-your-implementation-class"
  },"156": {
    "doc": "üîß Platform Integration",
    "title": "Step 2: Platform-Specific Examples",
    "content": "ESP32 (ESP-IDF) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . | #include \"driver/i2c.h\" #include \"pcal95555.hpp\" class Esp32I2cBus : public pcal95555::I2cInterface&lt;Esp32I2cBus&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t* data, size_t len) { i2c_cmd_handle_t cmd = i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, reg, true); i2c_master_write(cmd, (uint8_t*)data, len, true); i2c_master_stop(cmd); esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); return ret == ESP_OK; } bool Read(uint8_t addr, uint8_t reg, uint8_t* data, size_t len) { i2c_cmd_handle_t cmd = i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, reg, true); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_READ, true); i2c_master_read(cmd, data, len, I2C_MASTER_LAST_NACK); i2c_master_stop(cmd); esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); return ret == ESP_OK; } }; . | . STM32 (HAL) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 . | #include \"stm32f4xx_hal.h\" #include \"pcal95555.hpp\" extern I2C_HandleTypeDef hi2c1; class STM32I2cBus : public pcal95555::I2cInterface&lt;STM32I2cBus&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // STM32 HAL uses 8-bit address (7-bit &lt;&lt; 1) return HAL_I2C_Mem_Write(&amp;hi2c1, addr &lt;&lt; 1, reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)data, len, HAL_MAX_DELAY) == HAL_OK; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { return HAL_I2C_Mem_Read(&amp;hi2c1, addr &lt;&lt; 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, HAL_MAX_DELAY) == HAL_OK; } }; . | . Arduino . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 . | #include &lt;Wire.h&gt; #include \"pcal95555.hpp\" class ArduinoI2cBus : public pcal95555::I2cInterface&lt;ArduinoI2cBus&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { Wire.beginTransmission(addr); Wire.write(reg); Wire.write(data, len); return Wire.endTransmission() == 0; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { Wire.beginTransmission(addr); Wire.write(reg); if (Wire.endTransmission(false) != 0) return false; Wire.requestFrom(addr, len); for (size_t i = 0; i &lt; len &amp;&amp; Wire.available(); i++) { data[i] = Wire.read(); } return true; } }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#step-2-platform-specific-examples",
    
    "relUrl": "/docs/platform_integration/#step-2-platform-specific-examples"
  },"157": {
    "doc": "üîß Platform Integration",
    "title": "Common Pitfalls",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#common-pitfalls",
    
    "relUrl": "/docs/platform_integration/#common-pitfalls"
  },"158": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Use Virtual Functions",
    "content": "| 1 2 3 4 5 6 7 . | // WRONG - defeats the purpose of CRTP class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: virtual bool Write(...) override { // ‚ùå Virtual keyword not needed // ... } }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#-dont-use-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#-dont-use-virtual-functions"
  },"159": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct CRTP Implementation",
    "content": "| 1 2 3 4 5 6 7 . | // CORRECT - no virtual keyword class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: bool Write(...) { // ‚úÖ Direct implementation // ... } }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#-correct-crtp-implementation",
    
    "relUrl": "/docs/platform_integration/#-correct-crtp-implementation"
  },"160": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Forget the Template Parameter",
    "content": "| 1 2 3 4 . | // WRONG - missing template parameter class MyI2c : public pcal95555::I2cInterface { // ‚ùå Compiler error // ... }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#-dont-forget-the-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-dont-forget-the-template-parameter"
  },"161": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct Template Parameter",
    "content": "| 1 2 3 4 . | // CORRECT - pass your class as template parameter class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { // ‚úÖ // ... }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#-correct-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-correct-template-parameter"
  },"162": {
    "doc": "üîß Platform Integration",
    "title": "Testing Your Implementation",
    "content": "After implementing the interface, test it: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | MyPlatformI2c i2c; // Constructor takes A0, A1, A2 pin levels (all LOW = address 0x20, default) // Optional: pass ChipVariant to skip auto-detection pcal95555::PCAL95555&lt;MyPlatformI2c&gt; gpio(&amp;i2c, false, false, false); gpio.ResetToDefault(); // Check which chip variant was detected if (gpio.HasAgileIO()) { printf(\"PCAL9555A detected - full feature set\\n\"); } else { printf(\"PCA9555 detected - standard GPIO only\\n\"); } gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyPlatformI2c&gt;::GPIODir::Output); gpio.WritePin(0, true); bool value = gpio.ReadPin(1); // Interface works! . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#testing-your-implementation",
    
    "relUrl": "/docs/platform_integration/#testing-your-implementation"
  },"163": {
    "doc": "üîß Platform Integration",
    "title": "Next Steps",
    "content": ". | See Configuration for driver configuration options | Check Examples for complete usage examples | Review API Reference for all available methods | . Navigation ‚¨ÖÔ∏è Hardware Setup | Next: Configuration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#next-steps",
    
    "relUrl": "/docs/platform_integration/#next-steps"
  },"164": {
    "doc": "üîß Platform Integration",
    "title": "üîß Platform Integration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/",
    
    "relUrl": "/docs/platform_integration/"
  },"165": {
    "doc": "‚ö° Quick Start",
    "title": "Quick Start",
    "content": "This guide will get you up and running with the PCAL95555 driver in just a few steps. ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#quick-start",
    
    "relUrl": "/docs/quickstart/#quick-start"
  },"166": {
    "doc": "‚ö° Quick Start",
    "title": "Prerequisites",
    "content": ". | Driver installed | Hardware wired | I2C interface implemented | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#prerequisites",
    
    "relUrl": "/docs/quickstart/#prerequisites"
  },"167": {
    "doc": "‚ö° Quick Start",
    "title": "Minimal Example",
    "content": "Here‚Äôs a complete working example: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 . | #include \"pcal95555.hpp\" // 1. Implement the I2C interface class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // Your I2C write implementation return true; } bool Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { // Your I2C read implementation return true; } }; // 2. Create instances MyI2c i2c; // Option 1: Using address directly (recommended) pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); // Address 0x20 (default) // Option 2: Using pin levels // pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, false, false, false); // A0=LOW, A1=LOW, A2=LOW -&gt; 0x20 // Option 3: Force chip variant (skip auto-detection) // pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20, pcal95555::ChipVariant::PCA9555); // 3. Initialize (lazy initialization - happens automatically on first use) // You can also explicitly initialize: if (!gpio.EnsureInitialized()) { // Handle initialization failure return; } // Reset to default state gpio.ResetToDefault(); // all pins become inputs with pull-ups // 4. Check chip variant (auto-detected during init) if (gpio.HasAgileIO()) { // PCAL9555A detected -- pull resistors, drive strength, etc. available } else { // PCA9555 detected -- standard GPIO only } // 5. Configure and use gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.WritePin(0, true); bool input = gpio.ReadPin(1); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#minimal-example",
    
    "relUrl": "/docs/quickstart/#minimal-example"
  },"168": {
    "doc": "‚ö° Quick Start",
    "title": "Step-by-Step Explanation",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-by-step-explanation",
    
    "relUrl": "/docs/quickstart/#step-by-step-explanation"
  },"169": {
    "doc": "‚ö° Quick Start",
    "title": "Step 1: Include the Header",
    "content": "| 1 . | #include \"pcal95555.hpp\" . | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-1-include-the-header",
    
    "relUrl": "/docs/quickstart/#step-1-include-the-header"
  },"170": {
    "doc": "‚ö° Quick Start",
    "title": "Step 2: Implement the I2C Interface",
    "content": "You need to implement the I2cInterface for your platform. See Platform Integration for detailed examples for ESP32, STM32, and Arduino. The interface requires two methods: . | Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) - Write data to a register | Read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) - Read data from a register | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-2-implement-the-i2c-interface",
    
    "relUrl": "/docs/quickstart/#step-2-implement-the-i2c-interface"
  },"171": {
    "doc": "‚ö° Quick Start",
    "title": "Step 3: Create Driver Instance",
    "content": "You can create the driver instance in two ways: . Option 1: Using I2C address directly (recommended) . | 1 2 . | MyI2c i2c; pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); // Address 0x20 (default) . | . Option 2: Using address pin levels . | 1 2 3 . | MyI2c i2c; // Constructor takes A2, A1, A0 pin levels (all LOW = address 0x20, default) pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, false, false, false); . | . Constructor Parameters: . Using address (Option 1): . | Pointer to your I2C interface implementation | I2C address (0x20 to 0x27). Address bits are calculated automatically. | . Using pin levels (Option 2): . | Pointer to your I2C interface implementation | A0 pin level (true = HIGH/VDD, false = LOW/GND) | A1 pin level (true = HIGH/VDD, false = LOW/GND) | A2 pin level (true = HIGH/VDD, false = LOW/GND) | . The I2C address is calculated automatically: base address 0x20 + (A2¬´2 | A1¬´1 | A0). For example: . | Address 0x20 ‚Üí A0=LOW, A1=LOW, A2=LOW (default) | Address 0x21 ‚Üí A0=HIGH, A1=LOW, A2=LOW | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-3-create-driver-instance",
    
    "relUrl": "/docs/quickstart/#step-3-create-driver-instance"
  },"172": {
    "doc": "‚ö° Quick Start",
    "title": "Step 4: Initialize",
    "content": "The driver uses lazy initialization - it initializes automatically on first use. However, you can explicitly initialize: . | 1 2 3 4 5 6 7 8 . | // Explicit initialization (optional) if (!gpio.EnsureInitialized()) { // Handle initialization failure return; } // Reset to default state gpio.ResetToDefault(); . | . Lazy Initialization: . | The driver initializes automatically when you call any method that requires I2C communication | Initialization includes setting address pins, verifying I2C communication, auto-detecting the chip variant (PCA9555 vs PCAL9555A), and initializing internal state | If initialization fails, methods return false or appropriate error values | You can call EnsureInitialized() explicitly to verify initialization before use | . Chip Variant Detection: . | The driver automatically probes the Agile I/O register bank to determine if the chip is a PCA9555 or PCAL9555A | Use HasAgileIO() to check if PCAL9555A features are available | Use GetChipVariant() to get the specific variant enum | PCAL9555A-only methods return false and set Error::UnsupportedFeature on a PCA9555 | . ResetToDefault() puts the device in a known state (all pins as inputs with pull-ups enabled on PCAL9555A). ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-4-initialize",
    
    "relUrl": "/docs/quickstart/#step-4-initialize"
  },"173": {
    "doc": "‚ö° Quick Start",
    "title": "Step 5: Configure and Use Pins",
    "content": "| 1 2 3 4 5 6 7 8 . | // Set pin 0 as output gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); // Write to pin 0 gpio.WritePin(0, true); // Read from pin 1 (input) bool value = gpio.ReadPin(1); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-5-configure-and-use-pins",
    
    "relUrl": "/docs/quickstart/#step-5-configure-and-use-pins"
  },"174": {
    "doc": "‚ö° Quick Start",
    "title": "Expected Output",
    "content": "When running this example: . | Pin 0 should be set high (if connected to an LED, it should light up) | Pin 1 value should be read correctly | No error messages should appear | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#expected-output",
    
    "relUrl": "/docs/quickstart/#expected-output"
  },"175": {
    "doc": "‚ö° Quick Start",
    "title": "Troubleshooting",
    "content": "If you encounter issues: . | Compilation errors: Check that you‚Äôve implemented all required I2C interface methods | Initialization fails: Verify hardware connections and I2C address | No response: Check I2C bus and pull-up resistors | See: Troubleshooting for common issues | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#troubleshooting",
    
    "relUrl": "/docs/quickstart/#troubleshooting"
  },"176": {
    "doc": "‚ö° Quick Start",
    "title": "Next Steps",
    "content": ". | Explore Examples for more advanced usage | Review the API Reference for all available methods | Check Configuration for customization options | . Navigation ‚¨ÖÔ∏è Installation | Next: Hardware Setup ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#next-steps",
    
    "relUrl": "/docs/quickstart/#next-steps"
  },"177": {
    "doc": "‚ö° Quick Start",
    "title": "‚ö° Quick Start",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/",
    
    "relUrl": "/docs/quickstart/"
  },"178": {
    "doc": "üêõ Troubleshooting",
    "title": "Troubleshooting",
    "content": "This guide helps you diagnose and resolve common issues when using the PCAL95555 driver. ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#troubleshooting",
    
    "relUrl": "/docs/troubleshooting/#troubleshooting"
  },"179": {
    "doc": "üêõ Troubleshooting",
    "title": "Common Error Messages",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#common-error-messages",
    
    "relUrl": "/docs/troubleshooting/#common-error-messages"
  },"180": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Device Not Detected",
    "content": "Symptoms: . | ResetToDefault() or other operations fail | No response from device | . Causes: . | Wrong I2C address | Hardware connections incorrect | Pull-up resistors missing | . Solutions: . | Check I2C address: . | Default is 0x20 (all A0-A2 pins to GND) | Use I2C scanner to verify device address | Update address pin levels in constructor if different: | 1 2 . | // For address 0x21: A0=HIGH, A1=LOW, A2=LOW PCAL95555 driver(bus, true, false, false); . | . | Use GetAddress() to verify current address: | 1 2 . | uint8_t addr = driver.GetAddress(); printf(\"Current address: 0x%02X\\n\", addr); . | . | . | Verify hardware connections: . | Check SDA/SCL connections | Verify 4.7kŒ© pull-up resistors on SCL and SDA | Ensure power connections (VDD and GND) | . | Test I2C bus: . | Verify I2C bus is properly initialized | Check I2C bus speed (try 100 kHz if 400 kHz fails) | . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-device-not-detected",
    
    "relUrl": "/docs/troubleshooting/#error-device-not-detected"
  },"181": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Invalid Pin",
    "content": "Symptoms: . | Methods return false | Pin operations fail | . Causes: . | Pin number &gt;= 16 | Invalid pin parameter | . Solutions: . | 1 2 3 4 . | // Valid pins are 0-15 if (pin &lt; 16) { gpio.SetPinDirection(pin, dir); } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-invalid-pin",
    
    "relUrl": "/docs/troubleshooting/#error-invalid-pin"
  },"182": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: I2C Communication Failures",
    "content": "Symptoms: . | Operations fail intermittently | Timeout errors | . Solutions: . | Increase retries: | 1 . | gpio.SetRetries(3); // Default is 0 . | . | Check bus speed: Reduce I2C speed if using long wires . | Verify signal integrity: Check for noise on I2C lines | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-i2c-communication-failures",
    
    "relUrl": "/docs/troubleshooting/#error-i2c-communication-failures"
  },"183": {
    "doc": "üêõ Troubleshooting",
    "title": "Hardware Issues",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#hardware-issues",
    
    "relUrl": "/docs/troubleshooting/#hardware-issues"
  },"184": {
    "doc": "üêõ Troubleshooting",
    "title": "Device Not Responding",
    "content": "Symptoms: . | No response to I2C commands | Initialization fails | . Checklist: . | Verify power supply voltage (1.65V-5.5V) | Check all connections are secure | Verify pull-up resistors (4.7kŒ©) on SCL and SDA | Check I2C address configuration (A0-A2 pins) | Use I2C scanner to detect device address | Verify ground connection | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#device-not-responding",
    
    "relUrl": "/docs/troubleshooting/#device-not-responding"
  },"185": {
    "doc": "üêõ Troubleshooting",
    "title": "Incorrect Pin States",
    "content": "Symptoms: . | Pins don‚Äôt respond to writes | Reads return wrong values | . Checklist: . | Verify pin direction is set correctly | Check pin is configured as output before writing | Verify pull resistors are configured if needed | Check for external loads affecting pin state | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#incorrect-pin-states",
    
    "relUrl": "/docs/troubleshooting/#incorrect-pin-states"
  },"186": {
    "doc": "üêõ Troubleshooting",
    "title": "Software Issues",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#software-issues",
    
    "relUrl": "/docs/troubleshooting/#software-issues"
  },"187": {
    "doc": "üêõ Troubleshooting",
    "title": "Compilation Errors",
    "content": "Error: ‚ÄúNo matching function‚Äù . Solution: . | Ensure you‚Äôve implemented all required I2cInterface methods | Check method signatures match exactly | . Error: ‚ÄúUndefined reference‚Äù . Solution: . | Verify you‚Äôre including the header file | Check include paths are correct | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#compilation-errors",
    
    "relUrl": "/docs/troubleshooting/#compilation-errors"
  },"188": {
    "doc": "üêõ Troubleshooting",
    "title": "Runtime Errors",
    "content": "Initialization Fails . Checklist: . | I2C interface is properly implemented | I2C bus is initialized | Hardware connections are correct | I2C address matches hardware configuration | . Pin Operations Fail . Checklist: . | Pin number is valid (0-15) | Pin direction is set correctly | I2C communication is working | Error flags are checked | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#runtime-errors",
    
    "relUrl": "/docs/troubleshooting/#runtime-errors"
  },"189": {
    "doc": "üêõ Troubleshooting",
    "title": "Debugging Tips",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#debugging-tips",
    
    "relUrl": "/docs/troubleshooting/#debugging-tips"
  },"190": {
    "doc": "üêõ Troubleshooting",
    "title": "Enable Debug Output",
    "content": "Add debug prints to your I2C interface: . | 1 2 3 4 5 6 7 . | bool Write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { printf(\"I2C Write: addr=0x%02X, reg=0x%02X, len=%zu\\n\", addr, reg, len); // ... your implementation bool result = /* ... */; printf(\"Result: %s\\n\", result ? \"OK\" : \"FAIL\"); return result; } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#enable-debug-output",
    
    "relUrl": "/docs/troubleshooting/#enable-debug-output"
  },"191": {
    "doc": "üêõ Troubleshooting",
    "title": "Check Error Flags",
    "content": "| 1 2 3 . | gpio.ClearErrorFlags(); // Clear all errors // Perform operation // Check if errors occurred . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#check-error-flags",
    
    "relUrl": "/docs/troubleshooting/#check-error-flags"
  },"192": {
    "doc": "üêõ Troubleshooting",
    "title": "Use I2C Scanner",
    "content": "Scan the I2C bus to verify device detection: . | 1 2 3 4 5 6 7 8 . | void i2c_scanner() { for (uint8_t addr = 0x08; addr &lt; 0x78; addr++) { // Try to communicate with address if (/* device responds */) { printf(\"Device found at 0x%02X\\n\", addr); } } } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#use-i2c-scanner",
    
    "relUrl": "/docs/troubleshooting/#use-i2c-scanner"
  },"193": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Invalid Address (InvalidAddress)",
    "content": "Symptoms: . | Constructor or ChangeAddress() sets Error::InvalidAddress (flag 0x0020) | Methods fail after providing an out-of-range address | . Cause: The I2C address provided is outside the valid range 0x20-0x27. The PCA9555/PCAL9555A only responds to addresses in this range (determined by the A0-A2 hardware pins). Solutions: . | Check address parameter: Ensure the address is between 0x20 and 0x27: | 1 2 3 4 5 . | // Valid: address in 0x20-0x27 range PCAL95555 driver(bus, 0x20); // Invalid: will set Error::InvalidAddress PCAL95555 driver(bus, 0x50); . | . | Use pin-level constructor: The pin-level constructor always computes a valid address: | 1 . | PCAL95555 driver(bus, false, false, false); // Always valid (0x20) . | . | Check error flags: After construction, verify no errors: | 1 2 3 . | if (driver.GetErrorFlags() &amp; static_cast&lt;uint16_t&gt;(Error::InvalidAddress)) { printf(\"Invalid I2C address!\\n\"); } . | . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-invalid-address-invalidaddress",
    
    "relUrl": "/docs/troubleshooting/#error-invalid-address-invalidaddress"
  },"194": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: PCAL9555A Features Fail (UnsupportedFeature)",
    "content": "Symptoms: . | SetPullEnable(), SetDriveStrength(), SetOutputMode(), EnableInputLatch(), ConfigureInterrupt(), or GetInterruptStatus() return false | Error flags show 0x0010 (UnsupportedFeature) | . Cause: The connected chip is a PCA9555 (standard variant), not a PCAL9555A. These methods require the Agile I/O register bank (0x40-0x4F) that only exists on the PCAL9555A. Solutions: . | Check chip variant: Use HasAgileIO() before calling PCAL9555A features: | 1 2 3 4 5 . | if (gpio.HasAgileIO()) { gpio.SetDriveStrength(0, DriveStrength::Level2); } else { // Use external components or skip this feature } . | . | Verify hardware: Confirm your chip is actually a PCAL9555A (check part number marking) | Use external components: For PCA9555, use external pull-up resistors instead of internal ones | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-pcal9555a-features-fail-unsupportedfeature",
    
    "relUrl": "/docs/troubleshooting/#error-pcal9555a-features-fail-unsupportedfeature"
  },"195": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: ChipVariant Shows ‚ÄúUnknown‚Äù",
    "content": "Symptoms: . | GetChipVariant() returns ChipVariant::Unknown | HasAgileIO() returns false | . Cause: The 3-step chip detection probe could not confirm the chip type. This usually means the bus was unhealthy during initialization. Solutions: . | Check I2C pull-up resistors (4.7kŒ© on SDA and SCL) | Verify power supply is stable | Ensure no other I2C master is on the bus | Force the variant in the constructor to skip detection: | 1 . | PCAL95555 driver(bus, 0x20, pcal95555::ChipVariant::PCA9555); . | . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-chipvariant-shows-unknown",
    
    "relUrl": "/docs/troubleshooting/#error-chipvariant-shows-unknown"
  },"196": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: I2C NACKs on Registers 0x40-0x4F During Init",
    "content": "Symptoms: . | Log shows ‚ÄúI2C transaction unexpected nack detected‚Äù for registers 0x40-0x4F | Driver still initializes successfully | . Cause: This is expected behavior when a PCA9555 is connected. The auto-detection probe tries to access an Agile I/O register (0x4F). A NACK means the chip is a standard PCA9555. The driver detects this and sets ChipVariant::PCA9555. Resolution: No action needed. This is normal. The NACK errors come from the ESP-IDF I2C driver and can be safely ignored. ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-i2c-nacks-on-registers-0x40-0x4f-during-init",
    
    "relUrl": "/docs/troubleshooting/#error-i2c-nacks-on-registers-0x40-0x4f-during-init"
  },"197": {
    "doc": "üêõ Troubleshooting",
    "title": "FAQ",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#faq",
    
    "relUrl": "/docs/troubleshooting/#faq"
  },"198": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Why do my pin writes not work?",
    "content": "A: Common causes: . | Pin not configured as output: Call SetPinDirection(pin, GPIODir::Output) first | Wrong pin number: Valid pins are 0-15 | I2C communication failure: Check I2C bus and connections | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-why-do-my-pin-writes-not-work",
    
    "relUrl": "/docs/troubleshooting/#q-why-do-my-pin-writes-not-work"
  },"199": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: How do I use interrupts?",
    "content": "A: There are two ways to handle interrupts: . Method 1: Per-pin callbacks (recommended) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | // Configure pin as input gpio.SetPinDirection(pin, GPIODir::Input); gpio.SetPullEnable(pin, true); gpio.EnableInputLatch(pin, true); // Enable interrupt (easy-to-use method) gpio.ConfigureInterrupt(pin, InterruptState::Enabled); // Register per-pin callback gpio.RegisterPinInterrupt(pin, InterruptEdge::Rising, [](uint16_t p, bool state) { printf(\"Pin %d interrupt!\\n\", p); }); // Register interrupt handler with I2C interface (for hardware INT pin) gpio.RegisterInterruptHandler(); // Handle interrupt (called automatically if INT pin configured, or call manually) gpio.HandleInterrupt(); . | . Method 2: Global callback . | 1 2 3 . | gpio.SetInterruptCallback([](uint16_t status) { printf(\"Interrupt on pins: 0x%04X\\n\", status); }); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-how-do-i-use-interrupts",
    
    "relUrl": "/docs/troubleshooting/#q-how-do-i-use-interrupts"
  },"200": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Can I use multiple devices?",
    "content": "A: Yes! Configure different I2C addresses via A0-A2 pins, then create separate driver instances. You can even mix PCA9555 and PCAL9555A on the same bus: . | 1 2 3 4 5 6 7 . | // First device: PCA9555 at 0x20 pcal95555::PCAL95555&lt;MyI2c&gt; gpio1(&amp;i2c, false, false, false); // Second device: PCAL9555A at 0x21 pcal95555::PCAL95555&lt;MyI2c&gt; gpio2(&amp;i2c, true, false, false); // Each auto-detects its own chip variant . | . You can also change the address dynamically if your I2C interface supports GPIO control: . | 1 2 3 . | if (gpio1.ChangeAddress(true, false, false)) { printf(\"Address changed to 0x%02X\\n\", gpio1.GetAddress()); // Now 0x21 } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-can-i-use-multiple-devices",
    
    "relUrl": "/docs/troubleshooting/#q-can-i-use-multiple-devices"
  },"201": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: How do I know which chip I have (PCA9555 vs PCAL9555A)?",
    "content": "A: The driver auto-detects during initialization: . | 1 2 3 4 5 6 . | gpio.EnsureInitialized(); if (gpio.HasAgileIO()) { printf(\"PCAL9555A (extended features available)\\n\"); } else { printf(\"PCA9555 (standard GPIO only)\\n\"); } . | . You can also check the chip marking. PCA9555 has part number ‚ÄúPCA9555‚Äù; PCAL9555A has ‚ÄúPCAL9555A‚Äù. ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-how-do-i-know-which-chip-i-have-pca9555-vs-pcal9555a",
    
    "relUrl": "/docs/troubleshooting/#q-how-do-i-know-which-chip-i-have-pca9555-vs-pcal9555a"
  },"202": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What‚Äôs the difference between pull-up and pull-down?",
    "content": "A: . | Pull-up: Resistor connects pin to VDD (default high when floating) | Pull-down: Resistor connects pin to GND (default low when floating) | . Choose based on your circuit requirements. ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-whats-the-difference-between-pull-up-and-pull-down",
    
    "relUrl": "/docs/troubleshooting/#q-whats-the-difference-between-pull-up-and-pull-down"
  },"203": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What drive strength levels are available?",
    "content": "A: The driver supports four drive strength levels: . | Level0: 25% drive strength (¬º) | Level1: 50% drive strength (¬Ω) | Level2: 75% drive strength (¬æ) | Level3: 100% drive strength (full) | . Example: . | 1 . | gpio.SetDriveStrength(pin, DriveStrength::Level1); // 50% strength . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-what-drive-strength-levels-are-available",
    
    "relUrl": "/docs/troubleshooting/#q-what-drive-strength-levels-are-available"
  },"204": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: How do I check for errors?",
    "content": "A: Use error flags to check for errors: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | uint16_t errors = gpio.GetErrorFlags(); if (errors &amp; static_cast&lt;uint16_t&gt;(Error::I2CReadFail)) { // I2C read failed (also set by ReadPins() on failure) } if (errors &amp; static_cast&lt;uint16_t&gt;(Error::I2CWriteFail)) { // I2C write failed } if (errors &amp; static_cast&lt;uint16_t&gt;(Error::InvalidPin)) { // Invalid pin number (&gt;= 16) } if (errors &amp; static_cast&lt;uint16_t&gt;(Error::UnsupportedFeature)) { // PCAL9555A feature called on PCA9555 } if (errors &amp; static_cast&lt;uint16_t&gt;(Error::InvalidAddress)) { // I2C address outside valid 0x20-0x27 range } gpio.ClearErrorFlags(); // Clear all errors // Or clear selectively: gpio.ClearErrorFlags(0x0001); // Clear only InvalidPin . | . Note: ReadPins() now properly reports Error::I2CReadFail when the underlying I2C read fails, instead of silently returning empty results. ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-how-do-i-check-for-errors",
    
    "relUrl": "/docs/troubleshooting/#q-how-do-i-check-for-errors"
  },"205": {
    "doc": "üêõ Troubleshooting",
    "title": "Getting More Help",
    "content": "If you‚Äôre still experiencing issues: . | Check the API Reference for method details | Review Examples for working code | Search existing issues on GitHub | Open a new issue with: . | Description of the problem | Steps to reproduce | Hardware setup details | Error messages/logs | I2C bus analyzer output (if available) | . | . Navigation ‚¨ÖÔ∏è Examples | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#getting-more-help",
    
    "relUrl": "/docs/troubleshooting/#getting-more-help"
  },"206": {
    "doc": "üêõ Troubleshooting",
    "title": "üêõ Troubleshooting",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/",
    
    "relUrl": "/docs/troubleshooting/"
  },"207": {
    "doc": "PCAL95555 Comprehensive Test Suite Documentation",
    "title": "PCAL95555 Comprehensive Test Suite Documentation",
    "content": "# PCAL95555 Comprehensive Test Suite Documentation ## Overview The comprehensive test suite (`pcal95555_comprehensive_test`) validates **all 43 public API methods** of the PCAL95555 driver across **20 test sections**. It supports both the standard **PCA9555** and the enhanced **PCAL9555A** -- the chip variant is auto-detected during initialization, and PCAL9555A-only tests are automatically **skipped** (not failed) when a standard PCA9555 is detected. ## Test Configuration ### Hardware Target - **MCU**: ESP32-S3 - **I2C Frequency**: 400 kHz - **Default I2C Address**: 0x20 (A2=LOW, A1=LOW, A0=LOW) ### Pin Configuration | Signal | ESP32-S3 GPIO | Chip Pin | Function |--------|---------------|----------|----------| SDA | GPIO4 | SDA | I2C Data Line | SCL | GPIO5 | SCL | I2C Clock Line | INT | GPIO7 | INT | Interrupt Output (open-drain) | A0 | GPIO45 | A0 | Address Bit 0 (controlled by MCU) | A1 | GPIO48 | A1 | Address Bit 1 (controlled by MCU) | A2 | GPIO47 | A2 | Address Bit 2 (controlled by MCU) | Test Indicator | GPIO14 | - | Visual test progress indicator | ### Address Pin Control The test suite uses GPIO-controlled address pins, allowing dynamic address configuration: - **A0**: Controlled via GPIO45 - **A1**: Controlled via GPIO48 - **A2**: Controlled via GPIO47 The driver automatically sets these pins during initialization. --- ## Chip Variant Handling During the \"Driver Init\" test, the driver performs a 3-step sandwich detection: 1. Read `INPUT_PORT_0` (0x00) to verify bus health 2. Probe `OUTPUT_CONF` (0x4F) for Agile I/O support 3. Read `INPUT_PORT_0` (0x00) again to confirm bus recovery The detected variant is logged: ``` Detected chip variant: PCA9555 (standard) Agile I/O support: NO ``` or ``` Detected chip variant: PCAL9555A (Agile I/O) Agile I/O support: YES ``` Tests requiring PCAL9555A log a skip message: ``` Skipping: Pull resistor config requires PCAL9555A (detected PCA9555) ``` --- ## Test Sections ### 1. Initialization Tests #### `test_i2c_bus_initialization()` **Purpose**: Validates I2C bus setup and configuration. **What it tests**: - I2C master bus creation - GPIO pin configuration for SDA/SCL - Address pin GPIO configuration (A0, A1, A2) **Expected Result**: I2C bus successfully initialized with all pins configured. #### `test_driver_initialization()` **Purpose**: Validates driver initialization, chip variant detection, and default state. **What it tests**: - Driver instance creation (address pin constructor) - I2C communication verification - Chip variant auto-detection (PCA9555 vs PCAL9555A) - `HasAgileIO()` and `GetChipVariant()` queries - Reset to default state - Error flag checking and clearing **Expected Result**: Driver initialized, chip variant detected and logged. --- ### 2. GPIO Direction Tests #### `test_single_pin_direction()` **Tests**: `SetPinDirection()` for each pin (0-15), input and output modes. #### `test_multiple_pin_direction()` **Tests**: `SetMultipleDirections()` using 16-bit mask for port-level direction control. --- ### 3. GPIO Read/Write Tests #### `test_pin_write()` **Tests**: `WritePin()` -- writing HIGH and LOW to individual pins. #### `test_pin_read()` **Tests**: `ReadPin()` -- reading all 16 pins sequentially. #### `test_pin_toggle()` **Tests**: `TogglePin()` -- toggling pin state multiple times with verification. --- ### 4. Pull Resistor Tests (PCAL9555A only) #### `test_pull_resistor_config()` **Tests**: `SetPullEnable()`, `SetPullDirection()` -- per-pin pull-up/pull-down configuration. **Auto-skip**: Returns `true` with skip message on PCA9555. --- ### 5. Drive Strength Tests (PCAL9555A only) #### `test_drive_strength()` **Tests**: `SetDriveStrength()` -- all 4 levels (Level0-Level3) on individual pins. **Auto-skip**: Returns `true` with skip message on PCA9555. --- ### 6. Output Mode Tests (PCAL9555A only) #### `test_output_mode()` **Tests**: `SetOutputMode()` -- push-pull and open-drain per port and both ports. **Auto-skip**: Returns `true` with skip message on PCA9555. --- ### 7. Polarity Tests #### `test_polarity_inversion()` **Tests**: `SetPinPolarity()`, `SetMultiplePolarities()` -- normal and inverted polarity, single pin and mask-based. --- ### 8. Input Latch Tests (PCAL9555A only) #### `test_input_latch()` **Tests**: `EnableInputLatch()`, `EnableMultipleInputLatches()` -- per-pin and mask-based latch enable/disable. **Auto-skip**: Returns `true` with skip message on PCA9555. --- ### 9. Interrupt Tests (partially PCAL9555A only) #### `test_interrupt_mask_config()` (PCAL9555A) **Tests**: `ConfigureInterruptMask()` -- 16-bit interrupt mask register. #### `test_interrupt_status()` (PCAL9555A) **Tests**: `GetInterruptStatus()` -- reading and clearing interrupt status. #### `test_pin_interrupt_callbacks()` **Tests**: `RegisterPinInterrupt()`, `SetInterruptCallback()` -- per-pin callbacks with edge detection (Rising, Falling, Both). #### `test_interrupt_handler_registration()` **Tests**: `RegisterInterruptHandler()` -- hardware INT pin setup. Passes even without INT pin connected. #### `test_interrupt_callback_unregistration()` **Tests**: `UnregisterPinInterrupt()` -- callback removal and double-unregister safety. #### `test_interrupt_config()` (PCAL9555A) **Tests**: Combined interrupt mask + status reading. --- ### 10. Port Operation Tests #### `test_port_operations()` **Tests**: `SetMultipleDirections()`, `WritePin()`, `ReadPin()` -- port 0 as output, port 1 as input, mixed operations. --- ### 11. Multi-Pin API Tests #### `test_write_pins_multi()` **Tests**: `WritePins()` -- writing multiple pins at once via initializer list. #### `test_read_pins_multi()` **Tests**: `ReadPins()` -- reading multiple pins at once, verifying result vector. #### `test_set_directions_multi()` **Tests**: `SetDirections()` -- mixed input/output per pin via initializer list. #### `test_set_polarities_multi()` **Tests**: `SetPolarities()` -- mixed polarity per pin via initializer list. --- ### 12. Address Management Tests #### `test_address_management()` **Tests**: - `GetAddress()`, `GetAddressBits()` -- reading current address - `ChangeAddress(bool, bool, bool)` -- changing address via pin levels - `ChangeAddress(uint8_t)` -- changing address via direct value - Address-based constructor `PCAL95555(bus, address)` -- creating a temporary driver **Note**: Address change to a non-existent device handles NACK gracefully. Original address is always restored. --- ### 13. Configuration Tests #### `test_config_and_init()` **Tests**: - `SetRetries()` -- setting 0, 3, and restoring to 1 - `EnsureInitialized()` -- on already-initialized and fresh driver instances --- ### 14. Multi-Pin PCAL9555A API Tests (PCAL9555A only) #### `test_multi_pin_pcal_apis()` **Tests**: - `SetPullEnables()` -- multi-pin pull enable via initializer list - `SetPullDirections()` -- multi-pin pull direction via initializer list - `SetDriveStrengths()` -- multi-pin drive strength via initializer list - `ConfigureInterrupt()` -- single-pin interrupt enable/disable - `ConfigureInterrupts()` -- multi-pin interrupt config via initializer list - `EnableInputLatches()` -- multi-pin input latch via initializer list **Auto-skip**: Returns `true` with skip message on PCA9555. --- ### 15. Interactive Input Tests (disabled by default) #### `test_interactive_input()` **Requires**: Momentary push-button between PCA9555 pin 0 and GND. **Tests**: - `ReadPin()` -- detecting physical button press - Pull-up configuration (internal on PCAL9555A, external on PCA9555) - `HandleInterrupt()` -- explicit manual call **Behavior**: 1. Displays a banner explaining hardware requirements 2. Configures pin 0 as input with pull-up 3. Waits 10 seconds for button press with countdown 4. If button detected: verifies press and release 5. If no button: logs warning and continues (does not fail) 6. Calls `HandleInterrupt()` explicitly to verify no crash **To enable**: Set `ENABLE_INTERACTIVE_INPUT_TESTS = true` in the test file. --- ### 16. Error Handling Tests #### `test_error_handling()` **Tests**: - Invalid pin (16, 17, 18) for `SetPinDirection()`, `ReadPin()`, `WritePin()`, `TogglePin()` - `GetErrorFlags()` -- verifying error flags are set - `ClearErrorFlags(mask)` -- selective flag clearing (specific mask vs all) - `Error::UnsupportedFeature` -- calling `SetDriveStrength()` on PCA9555 - `HandleInterrupt()` -- explicit call on clean state (no crash) --- ### 17. Stress Tests #### `test_rapid_operations()` **Tests**: Rapid `WritePin()` toggle (100 cycles at 1ms intervals) to verify I2C stability under load. --- ## Test Execution Flow 1. **Initialization Phase**: I2C bus setup, driver creation, chip variant detection 2. **Core GPIO Tests**: Direction, read/write, toggle 3. **PCAL9555A Feature Tests**: Pull resistors, drive strength, output mode, input latch, interrupts (auto-skip on PCA9555) 4. **Advanced API Tests**: Multi-pin operations, address management, configuration 5. **Robustness Tests**: Error handling, stress testing 6. **Cleanup Phase**: Resource cleanup, test summary reporting --- ## Enabling/Disabling Test Sections ```cpp static constexpr bool ENABLE_INITIALIZATION_TESTS = true; static constexpr bool ENABLE_GPIO_DIRECTION_TESTS = true; static constexpr bool ENABLE_GPIO_READ_WRITE_TESTS = true; static constexpr bool ENABLE_PULL_RESISTOR_TESTS = true; static constexpr bool ENABLE_DRIVE_STRENGTH_TESTS = true; static constexpr bool ENABLE_OUTPUT_MODE_TESTS = true; static constexpr bool ENABLE_POLARITY_TESTS = true; static constexpr bool ENABLE_INPUT_LATCH_TESTS = true; static constexpr bool ENABLE_INTERRUPT_TESTS = true; static constexpr bool ENABLE_PORT_OPERATION_TESTS = true; static constexpr bool ENABLE_MULTI_PIN_TESTS = true; static constexpr bool ENABLE_MULTI_PIN_API_TESTS = true; static constexpr bool ENABLE_ADDRESS_TESTS = true; static constexpr bool ENABLE_CONFIG_TESTS = true; static constexpr bool ENABLE_MULTI_PIN_PCAL_TESTS = true; static constexpr bool ENABLE_INTERACTIVE_INPUT_TESTS = false; // Requires button on pin 0 static constexpr bool ENABLE_ERROR_HANDLING_TESTS = true; static constexpr bool ENABLE_STRESS_TESTS = true; ``` --- ## Test Results Interpretation ### Success Indicators - `[SUCCESS] PASSED` -- test passed - `Skipping: ... requires PCAL9555A (detected PCA9555)` -- expected skip, counts as pass ### Warning Indicators - `Driver has error flags: 0xNNNN` -- I2C errors during init (may be expected on PCA9555) - `No button press detected within 10 seconds` -- interactive test timeout (OK) ### Failure Indicators - `[FAILED] FAILED` -- test failed, check error messages above it - `Error flags: 0xNNNN` -- see Error Flags table below ### Error Flags Reference | Flag | Value | Meaning |------|-------|---------| `InvalidPin` | 0x0001 | Pin index >= 16 | `InvalidMask` | 0x0002 | Mask bits outside valid range | `I2CReadFail` | 0x0004 | I2C read transaction failed | `I2CWriteFail` | 0x0008 | I2C write transaction failed | `UnsupportedFeature` | 0x0010 | PCAL9555A feature called on PCA9555 | --- ## Hardware Requirements ### Minimum - PCA9555 or PCAL9555A I/O expander - ESP32-S3 development board - I2C connections (SDA, SCL) with 4.7k pull-ups - Power connections (3.3V, GND) ### For Full Test Coverage - Address pins connected to GPIOs (A0=GPIO45, A1=GPIO48, A2=GPIO47) - INT pin connected to GPIO7 (for interrupt handler test) - LED on GPIO14 (test progress indicator) ### For Interactive Input Test - Momentary push-button between pin 0 and GND - 10k pull-up to VDD (PCA9555) or use internal pull-up (PCAL9555A) --- ## Expected Test Count | Chip Variant | Enabled Sections | Expected Tests | Expected Pass |-------------|-----------------|----------------|---------------| PCA9555 | All (default) | ~31 | 31 (PCAL tests skip as pass) | PCAL9555A | All (default) | ~31 | 31 | Either + Interactive | All + Interactive | ~32 | 32 | --- **Navigation** [Back to Examples README](/hf-pcal95555-driver/development/examples/esp32/) | [Main README](/hf-pcal95555-driver/development/) ",
    "url": "/hf-pcal95555-driver/development/examples/esp32/docs/comprehensive_test.html",
    
    "relUrl": "/examples/esp32/docs/comprehensive_test.html"
  },"208": {
    "doc": "PCA9555 / PCAL9555A ESP32-S3 Examples",
    "title": "PCA9555 / PCAL9555A ESP32-S3 Examples",
    "content": "# PCA9555 / PCAL9555A ESP32-S3 Examples This directory contains example applications for the HF-PCAL95555 driver on ESP32-S3, covering both the standard **PCA9555** and extended **PCAL9555A** 16-bit I/O expanders. --- ## Table of Contents - [Hardware Overview](#hardware-overview) - [Pin Connections](#pin-connections) - [Available Applications](#available-applications) - [Building](#building) - [Flashing and Monitoring](#flashing-and-monitoring) - [Comprehensive Test Suite](#comprehensive-test-suite) - [LED Animation Demo](#led-animation-demo) - [Configuration](#configuration) - [Troubleshooting](#troubleshooting) --- ## Hardware Overview ### ESP32-S3 The ESP32-S3 serves as the host controller for communicating with the PCA9555 / PCAL9555A GPIO expander via I2C. ``` ESP32-S3 Development Board ‚îú‚îÄ‚îÄ I2C: SDA (GPIO4), SCL (GPIO5) ‚îú‚îÄ‚îÄ INT: GPIO7 (open-drain, needs pull-up) ‚îú‚îÄ‚îÄ Address: A0 (GPIO45), A1 (GPIO48), A2 (GPIO47) ‚îî‚îÄ‚îÄ Indicator: GPIO14 (test progress LED) ``` ### PCA9555 / PCAL9555A Both chips provide 16 GPIO pins in two 8-bit ports over I2C. The driver auto-detects which variant is connected and enables features accordingly: | Feature | PCA9555 | PCAL9555A |---------|---------|-----------| 16 GPIO, I2C, polarity inversion | Yes | Yes | Pull-up / pull-down resistors | -- | Yes | Drive strength, input latch | -- | Yes | Interrupt mask / status | -- | Yes | Output mode (push-pull / OD) | -- | Yes | --- ## Pin Connections ### I2C Bus | Chip Pin | ESP32-S3 GPIO | Notes |----------|---------------|-------| SDA | GPIO4 | 4.7k pull-up to 3.3V | SCL | GPIO5 | 4.7k pull-up to 3.3V | VDD | 3.3V | | GND | GND | | INT | GPIO7 | Open-drain, 4.7k pull-up (optional) | ### Address Pins (GPIO-controlled) | Chip Pin | ESP32-S3 GPIO | Default |----------|---------------|---------| A0 | GPIO45 | LOW | A1 | GPIO48 | LOW | A2 | GPIO47 | LOW | Default address: **0x20** (all LOW) ### I2C Address Table | A2 | A1 | A0 | Address |----|----|----|---------| L | L | L | 0x20 | L | L | H | 0x21 | L | H | L | 0x22 | L | H | H | 0x23 | H | L | L | 0x24 | H | L | H | 0x25 | H | H | L | 0x26 | H | H | H | 0x27 | --- ## Available Applications | Application | Description |-------------|-------------| `pcal95555_comprehensive_test` | Full API test suite (17 sections, 43 methods) | `pcal95555_led_animation` | 16-LED animation demo (10 patterns) | ```bash # List all available apps ./scripts/build_app.sh list ``` --- ## Building ### Prerequisites - [ESP-IDF v5.5+](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/get-started/) - ESP32-S3 devkit - PCA9555 or PCAL9555A board connected via I2C ### Build Commands ```bash cd examples/esp32 # Build comprehensive test suite ./scripts/build_app.sh pcal95555_comprehensive_test Debug # Build LED animation demo ./scripts/build_app.sh pcal95555_led_animation Debug ``` --- ## Flashing and Monitoring ```bash # Flash and open serial monitor ./scripts/flash_app.sh flash_monitor pcal95555_comprehensive_test Debug # Flash only ./scripts/flash_app.sh flash pcal95555_comprehensive_test Debug # Monitor only (if already flashed) ./scripts/flash_app.sh monitor ``` > **ESP32-S3 native USB note:** If flashing fails on `/dev/ttyACM0`, manually enter > download mode: Hold **BOOT** -> Press **RESET** -> Release **BOOT** -> Run flash. --- ## Comprehensive Test Suite **File:** `main/pcal95555_comprehensive_test.cpp` Tests every public API method of the PCAL95555 driver class across 17 sections. PCAL9555A-specific tests are **automatically skipped** (not failed) on a standard PCA9555. ### Test Sections | # | Section | Methods Tested | PCAL9555A? |---|---------|----------------|------------| 1 | Initialization | Constructor, ResetToDefault, auto-detection | No | 2 | GPIO Direction (single) | SetPinDirection | No | 3 | GPIO Direction (multi) | SetMultipleDirections | No | 4 | Pin Write | WritePin | No | 5 | Pin Read | ReadPin | No | 6 | Pin Toggle | TogglePin | No | 7 | Pull Resistor | SetPullEnable, SetPullDirection | Yes | 8 | Drive Strength | SetDriveStrength | Yes | 9 | Output Mode | SetOutputMode | Yes | 10 | Polarity | SetPinPolarity, SetMultiplePolarities | No | 11 | Input Latch | EnableInputLatch, EnableMultipleInputLatches | Yes | 12 | Interrupt Config | ConfigureInterruptMask, GetInterruptStatus, callbacks | Yes | 13 | Port Operations | Mixed port direction + read/write | No | 14 | Multi-Pin APIs | WritePins, ReadPins, SetDirections, SetPolarities | No | 15 | Address Management | ChangeAddress, address-based constructor | No | 16 | Configuration | SetRetries, EnsureInitialized | No | 17 | Multi-Pin PCAL | SetPullEnables, SetDriveStrengths, ConfigureInterrupt/s, EnableInputLatches | Yes | 18 | Interactive Input | Button press, HandleInterrupt (disabled by default) | No | 19 | Error Handling | Invalid pins, UnsupportedFeature, flag clearing | No | 20 | Stress Tests | Rapid pin toggling | No | ### Enable/Disable Sections ```cpp // At top of pcal95555_comprehensive_test.cpp static constexpr bool ENABLE_INITIALIZATION_TESTS = true; static constexpr bool ENABLE_GPIO_DIRECTION_TESTS = true; static constexpr bool ENABLE_INTERACTIVE_INPUT_TESTS = false; // Requires button on pin 0 // ... etc ``` ### Interactive Input Test Disabled by default. Requires a momentary push-button between PCA9555 pin 0 and GND: - **PCAL9555A:** Internal pull-up is enabled automatically - **PCA9555:** Add an external 10k pull-up resistor to VDD The test waits 10 seconds for a button press, logging a countdown. If no button is connected, it times out gracefully without failing. ### Expected Output (PCA9555) ``` Detected chip variant: PCA9555 (standard) Agile I/O support: NO ... Skipping: Pull resistor config requires PCAL9555A (detected PCA9555) ... Total: 31, Passed: 31, Failed: 0, Success: 100.00% ``` --- ## LED Animation Demo **File:** `main/pcal95555_led_animation.cpp` Drives 16 LEDs through 10 animation patterns to visually test the driver's output capabilities and I2C throughput. Uses only PCA9555-compatible registers, so it works with both chip variants. ### Animation Patterns 1. **Sequential Chase** -- single LED scans left to right and back 2. **Bounce** -- LED bounces between endpoints with acceleration 3. **Binary Counter** -- counts 0-65535 showing binary on 16 LEDs 4. **Breathing (PWM)** -- software PWM fade-in/fade-out of all LEDs 5. **Wave / Comet Tail** -- 4-LED comet sweeps back and forth 6. **Random Sparkle** -- random LED patterns at fast rate 7. **Build-up / Teardown** -- LEDs light sequentially then extinguish 8. **Accelerating Scan** -- speed ramps from 120ms down to 1ms and back 9. **Center Expand** -- symmetric outward/inward animation from center 10. **Alternating Flash** -- port-vs-port and even-vs-odd flashing ### LED Wiring Connect LEDs with 220-1k current-limiting resistors to each I/O pin. - **Active-HIGH (default):** LED anode to IO pin, cathode to GND - **Active-LOW:** Set `LEDS_ACTIVE_LOW = true` in the source, LED cathode to IO pin, anode to VDD ### Configuration Edit at top of `pcal95555_led_animation.cpp`: ```cpp static constexpr uint16_t NUM_PINS = 16; static constexpr bool LEDS_ACTIVE_LOW = false; static constexpr int NUM_CYCLES = 0; // 0 = infinite ``` --- ## Configuration ### I2C Bus Default configuration in the bus header (`esp32_pcal95555_bus.hpp`): | Parameter | Default | Notes |-----------|---------|-------| I2C Port | I2C_NUM_0 | | SDA | GPIO4 | | SCL | GPIO5 | | Frequency | 400 kHz | Reduce to 100k for long wires | Internal Pull-ups | Enabled | External 4.7k recommended | ### Stack Size The test suite requires a larger-than-default main task stack due to extensive logging. Set in `sdkconfig`: ``` CONFIG_ESP_MAIN_TASK_STACK_SIZE=16384 ``` --- ## Troubleshooting ### I2C NACK Errors | Symptom | Likely Cause | Fix |---------|-------------|-----| NACK on all registers | Wrong address / no power | Check wiring, verify address | NACK on 0x40-0x4F only | PCA9555 (not PCAL9555A) | Expected -- driver auto-detects | Intermittent NACKs | Bus noise, missing pull-ups | Add 4.7k pull-ups | ### Stack Overflow / Assert ``` assert failed: xTaskRemoveFromEventList tasks.c ``` Increase stack size: `CONFIG_ESP_MAIN_TASK_STACK_SIZE=16384` in sdkconfig. ### ESP32-S3 Flash Failure ``` Failed to connect to ESP32-S3: Invalid head of packet (0x1B) ``` Manually enter download mode (BOOT + RESET) before flashing. ### ChipVariant \"Unknown\" The 3-step detection could not confirm chip type. Check: - I2C pull-ups present - Chip powered and wired correctly - No other I2C master on bus --- ## Additional Resources - [Main README](/hf-pcal95555-driver/development/) -- Full project documentation - [PCAL9555A Datasheet](/hf-pcal95555-driver/development/datasheet/PCAL9555A.pdf) - [Driver API Reference](/hf-pcal95555-driver/development/docs/api_reference/) - [Platform Integration Guide](/hf-pcal95555-driver/development/docs/platform_integration/) - [Build Scripts README](scripts/README.md) ",
    "url": "/hf-pcal95555-driver/development/examples/esp32/",
    
    "relUrl": "/examples/esp32/"
  }
}
