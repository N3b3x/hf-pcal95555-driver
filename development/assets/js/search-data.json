{"0": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "HF-PCAL95555 Driver",
    "content": "Hardware-agnostic C++ driver for the NXP PCAL9555A 16-bit I/O expander . ",
    "url": "/hf-pcal95555-driver/development/#hf-pcal95555-driver",
    
    "relUrl": "/#hf-pcal95555-driver"
  },"1": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "üìö Table of Contents",
    "content": ". | Overview | Features | Quick Start | Installation | API Reference | Examples | Documentation | Contributing | License | . ",
    "url": "/hf-pcal95555-driver/development/#-table-of-contents",
    
    "relUrl": "/#-table-of-contents"
  },"2": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "üì¶ Overview",
    "content": "üìñ üìöüåê Live Complete Documentation - Interactive guides, examples, and step-by-step tutorials . The PCAL9555A is a 16-bit I/O expander from NXP Semiconductors that communicates via I¬≤C. It provides 16 GPIO pins organized into two 8-bit ports (PORT_0: pins 0-7, PORT_1: pins 8-15), allowing you to expand your microcontroller‚Äôs I/O capabilities. The chip features per-pin interrupt capability, configurable pull-up/pull-down resistors, adjustable drive strength, and support for both push-pull and open-drain output modes. This driver provides a hardware-agnostic C++ interface that abstracts all register-level operations, requiring only an implementation of the I2cInterface for your platform. The driver uses the CRTP (Curiously Recurring Template Pattern) for zero-overhead hardware abstraction, making it suitable for resource-constrained embedded systems. ",
    "url": "/hf-pcal95555-driver/development/#-overview",
    
    "relUrl": "/#-overview"
  },"3": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "‚ú® Features",
    "content": ". | ‚úÖ 16 GPIO Pins: Two 8-bit ports (PORT_0: 0-7, PORT_1: 8-15) | ‚úÖ Per-Pin Configuration: Direction, pull-up/pull-down, drive strength, polarity | ‚úÖ Interrupt Support: Per-pin interrupt capability with input latching | ‚úÖ Hardware Agnostic: CRTP-based I2C interface for platform independence | ‚úÖ Modern C++: C++11 compatible with template-based design | ‚úÖ Zero Overhead: CRTP design for compile-time polymorphism | ‚úÖ Kconfig Integration: Optional compile-time configuration via Kconfig | ‚úÖ Error Handling: Comprehensive error reporting with retry support | . ",
    "url": "/hf-pcal95555-driver/development/#-features",
    
    "relUrl": "/#-features"
  },"4": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "üöÄ Quick Start",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | #include \"pcal95555.hpp\" // 1. Implement the I2C interface (see platform_integration.md) class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len); bool read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len); }; // 2. Create driver instance MyI2c i2c; pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); // 0x20 is default I2C address // 3. Initialize and use gpio.ResetToDefault(); // all pins become inputs with pull-ups gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.WritePin(0, true); bool input = gpio.ReadPin(1); . | . For detailed setup, see Installation and Quick Start Guide. ",
    "url": "/hf-pcal95555-driver/development/#-quick-start",
    
    "relUrl": "/#-quick-start"
  },"5": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "üîß Installation",
    "content": "This driver is designed to be integrated into your project. It‚Äôs a header-only template library with implementation included. | Add to your project: Copy or clone the driver files into your project | Implement the I2C interface for your platform (see Platform Integration) | Include the header in your code: | 1 . | #include \"pcal95555.hpp\" . | . | Compile with a C++11 or newer compiler | . For detailed installation instructions, see docs/installation.md. ",
    "url": "/hf-pcal95555-driver/development/#-installation",
    
    "relUrl": "/#-installation"
  },"6": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "üìñ API Reference",
    "content": "| Method | Description | . | ResetToDefault() | Reset device to power-on default state | . | SetPinDirection(pin, dir) | Set pin direction (input/output) | . | ReadPin(pin) | Read pin state | . | WritePin(pin, value) | Write pin state | . | SetPullEnable(pin, enable) | Enable/disable pull resistor | . | SetPullDirection(pin, pull_up) | Set pull-up or pull-down | . | SetDriveStrength(pin, level) | Set output drive strength | . | GetInterruptStatus() | Get interrupt status register | . For complete API documentation with source code links, see docs/api_reference.md. ",
    "url": "/hf-pcal95555-driver/development/#-api-reference",
    
    "relUrl": "/#-api-reference"
  },"7": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "üìä Examples",
    "content": "For ESP32 examples, see the examples/esp32 directory. Additional examples for other platforms are available in the examples directory. Detailed example walkthroughs are available in docs/examples.md. ",
    "url": "/hf-pcal95555-driver/development/#-examples",
    
    "relUrl": "/#-examples"
  },"8": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "üìö Documentation",
    "content": "For complete documentation, see the docs directory. ",
    "url": "/hf-pcal95555-driver/development/#-documentation",
    
    "relUrl": "/#-documentation"
  },"9": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "ü§ù Contributing",
    "content": "Pull requests and suggestions are welcome! Please follow the existing code style and include tests for new features. ",
    "url": "/hf-pcal95555-driver/development/#-contributing",
    
    "relUrl": "/#-contributing"
  },"10": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "üìÑ License",
    "content": "This project is licensed under the GNU General Public License v3.0. See the LICENSE file for details. ",
    "url": "/hf-pcal95555-driver/development/#-license",
    
    "relUrl": "/#-license"
  },"11": {
    "doc": "HardFOC PCAL95555 Driver",
    "title": "HardFOC PCAL95555 Driver",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/",
    
    "relUrl": "/"
  },"12": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Configuration",
    "content": "This guide covers all configuration options available for the PCAL95555 driver. ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#configuration",
    
    "relUrl": "/docs/configuration/#configuration"
  },"13": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "I2C Address Configuration",
    "content": "The PCAL9555A I2C address is configured via hardware pins A0-A2. Each pin represents one bit of the 3-bit address field. | Pin | Address Bit | Description | . | A0 | Bit 0 | Least significant address bit | . | A1 | Bit 1 | ¬† | . | A2 | Bit 2 | Most significant address bit | . Default I2C address: 0x20 (all address pins to GND) . Address Range: 0x20 to 0x27 (7-bit I2C addresses) . Example: To set address 0x21, connect A0 to VDD and A1-A2 to GND. ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#i2c-address-configuration",
    
    "relUrl": "/docs/configuration/#i2c-address-configuration"
  },"14": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Kconfig Configuration (Optional)",
    "content": "If your project uses Kconfig (e.g., ESP-IDF), the driver supports compile-time configuration: . Location: Kconfig . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#kconfig-configuration-optional",
    
    "relUrl": "/docs/configuration/#kconfig-configuration-optional"
  },"15": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Configuration Options",
    "content": ". | Per-pin direction: Configure each pin as input (1) or output (0) | Per-pin pull-up/pull-down: Enable pull resistors and select direction | Per-pin initial output: Set initial output state | Port open-drain: Configure ports for open-drain or push-pull mode | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#configuration-options",
    
    "relUrl": "/docs/configuration/#configuration-options"
  },"16": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Using Kconfig",
    "content": ". | Run idf.py menuconfig (or your Kconfig tool) | Navigate to component configuration | Configure per-pin settings as needed | Use InitFromConfig() to apply settings: | . | 1 . | gpio.InitFromConfig(); // Apply Kconfig settings . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#using-kconfig",
    
    "relUrl": "/docs/configuration/#using-kconfig"
  },"17": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Runtime Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#runtime-configuration",
    
    "relUrl": "/docs/configuration/#runtime-configuration"
  },"18": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Pin Direction",
    "content": "Set individual pin direction: . | 1 2 3 4 5 6 7 8 . | // Set pin 0 as output gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); // Set pin 1 as input gpio.SetPinDirection(1, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); // Set multiple pins at once gpio.SetMultipleDirections(0x000F, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); // Pins 0-3 . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#pin-direction",
    
    "relUrl": "/docs/configuration/#pin-direction"
  },"19": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Pull Resistors",
    "content": "Configure pull-up/pull-down resistors: . | 1 2 3 4 5 6 7 . | // Enable pull-up on pin 0 gpio.SetPullEnable(0, true); gpio.SetPullDirection(0, true); // true = pull-up, false = pull-down // Enable pull-down on pin 1 gpio.SetPullEnable(1, true); gpio.SetPullDirection(1, false); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#pull-resistors",
    
    "relUrl": "/docs/configuration/#pull-resistors"
  },"20": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Drive Strength",
    "content": "Set output drive strength: . | 1 . | gpio.SetDriveStrength(0, pcal95555::PCAL95555&lt;MyI2c&gt;::DriveStrength::Full); . | . Drive Strength Levels: . | Quarter: 25% drive strength | Half: 50% drive strength | ThreeQuarter: 75% drive strength | Full: 100% drive strength | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#drive-strength",
    
    "relUrl": "/docs/configuration/#drive-strength"
  },"21": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Output Mode",
    "content": "Configure port output mode (push-pull or open-drain): . | 1 2 . | // Set PORT_0 to open-drain, PORT_1 to push-pull gpio.SetOutputMode(true, false); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#output-mode",
    
    "relUrl": "/docs/configuration/#output-mode"
  },"22": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Polarity Inversion",
    "content": "Invert input polarity: . | 1 2 3 4 5 . | // Invert pin 0 polarity gpio.SetPinPolarity(0, pcal95555::PCAL95555&lt;MyI2c&gt;::Polarity::Inverted); // Invert multiple pins gpio.SetMultiplePolarities(0x00FF, pcal95555::PCAL95555&lt;MyI2c&gt;::Polarity::Inverted); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#polarity-inversion",
    
    "relUrl": "/docs/configuration/#polarity-inversion"
  },"23": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Default Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#default-configuration",
    
    "relUrl": "/docs/configuration/#default-configuration"
  },"24": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "ResetToDefault()",
    "content": "Resets all registers to power-on defaults: . | 1 . | gpio.ResetToDefault(); . | . Default State: . | All pins: Inputs with pull-ups enabled | Drive strength: Full | Output mode: Push-pull | Interrupts: Masked (disabled) | Polarity: Normal (not inverted) | . Location: src/pcal95555.cpp#L49 . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#resettodefault",
    
    "relUrl": "/docs/configuration/#resettodefault"
  },"25": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Interrupt Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#interrupt-configuration",
    
    "relUrl": "/docs/configuration/#interrupt-configuration"
  },"26": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Enable Interrupts",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 . | // Configure interrupt mask (0 = enabled, 1 = masked) gpio.ConfigureInterruptMask(0xFF00); // Enable interrupts on PORT_1 (pins 8-15) // Set interrupt callback gpio.SetInterruptCallback([](uint16_t status) { // Handle interrupt printf(\"Interrupt on pins: 0x%04X\\n\", status); }); // Handle interrupt (call from ISR or polling) gpio.HandleInterrupt(); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#enable-interrupts",
    
    "relUrl": "/docs/configuration/#enable-interrupts"
  },"27": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Get Interrupt Status",
    "content": "| 1 2 . | uint16_t status = gpio.GetInterruptStatus(); // Check which pins triggered interrupt . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#get-interrupt-status",
    
    "relUrl": "/docs/configuration/#get-interrupt-status"
  },"28": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Recommended Settings",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#recommended-settings",
    
    "relUrl": "/docs/configuration/#recommended-settings"
  },"29": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Input Pins",
    "content": "| 1 2 3 . | gpio.SetPinDirection(pin, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); gpio.SetPullEnable(pin, true); gpio.SetPullDirection(pin, true); // Pull-up . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#for-input-pins",
    
    "relUrl": "/docs/configuration/#for-input-pins"
  },"30": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Output Pins",
    "content": "| 1 2 3 . | gpio.SetPinDirection(pin, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.SetDriveStrength(pin, pcal95555::PCAL95555&lt;MyI2c&gt;::DriveStrength::Full); gpio.WritePin(pin, false); // Set initial state . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#for-output-pins",
    
    "relUrl": "/docs/configuration/#for-output-pins"
  },"31": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Interrupt-Driven Inputs",
    "content": "| 1 2 3 4 5 . | gpio.SetPinDirection(pin, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); gpio.SetPullEnable(pin, true); gpio.SetPullDirection(pin, true); gpio.EnableInputLatch(pin, true); // Latch input changes gpio.ConfigureInterruptMask(~(1 &lt;&lt; pin)); // Enable interrupt for this pin . | . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#for-interrupt-driven-inputs",
    
    "relUrl": "/docs/configuration/#for-interrupt-driven-inputs"
  },"32": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Next Steps",
    "content": ". | See Examples for configuration examples | Review API Reference for all configuration methods | . Navigation ‚¨ÖÔ∏è Platform Integration | Next: API Reference ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/#next-steps",
    
    "relUrl": "/docs/configuration/#next-steps"
  },"33": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "‚öôÔ∏è Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/configuration/",
    
    "relUrl": "/docs/configuration/"
  },"34": {
    "doc": "üí° Examples",
    "title": "Examples",
    "content": "This guide provides complete, working examples demonstrating various use cases for the PCAL95555 driver. ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#examples",
    
    "relUrl": "/docs/examples/#examples"
  },"35": {
    "doc": "üí° Examples",
    "title": "Example 1: Basic GPIO Control",
    "content": "This example shows basic input/output operations. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 . | #include \"pcal95555.hpp\" // Implement I2C interface (see platform_integration.md) class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { // ... implement write() and read() }; MyI2c i2c; pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); void app_main(void) { gpio.ResetToDefault(); // Configure pin 0 as output gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.WritePin(0, true); // Configure pin 1 as input gpio.SetPinDirection(1, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); bool value = gpio.ReadPin(1); } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-1-basic-gpio-control",
    
    "relUrl": "/docs/examples/#example-1-basic-gpio-control"
  },"36": {
    "doc": "üí° Examples",
    "title": "Explanation",
    "content": ". | Reset: Put device in known state | Configure: Set pin directions | Use: Read and write pin states | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#explanation",
    
    "relUrl": "/docs/examples/#explanation"
  },"37": {
    "doc": "üí° Examples",
    "title": "Example 2: Multiple Pins",
    "content": "This example demonstrates configuring multiple pins at once. | 1 2 3 4 5 6 7 . | // Set pins 0-7 as outputs gpio.SetMultipleDirections(0x00FF, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); // Write to multiple pins for (int i = 0; i &lt; 8; i++) { gpio.WritePin(i, (i % 2 == 0)); // Alternate pattern } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-2-multiple-pins",
    
    "relUrl": "/docs/examples/#example-2-multiple-pins"
  },"38": {
    "doc": "üí° Examples",
    "title": "Example 3: Interrupt Handling",
    "content": "This example shows how to use interrupts. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | // Configure pin 8 as input with interrupt gpio.SetPinDirection(8, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); gpio.SetPullEnable(8, true); gpio.SetPullDirection(8, true); // Pull-up gpio.EnableInputLatch(8, true); gpio.ConfigureInterruptMask(~(1 &lt;&lt; 8)); // Enable interrupt // Set callback gpio.SetInterruptCallback([](uint16_t status) { printf(\"Interrupt on pins: 0x%04X\\n\", status); // Handle interrupt }); // In your main loop or ISR gpio.HandleInterrupt(); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-3-interrupt-handling",
    
    "relUrl": "/docs/examples/#example-3-interrupt-handling"
  },"39": {
    "doc": "üí° Examples",
    "title": "Example 4: Pull Resistors",
    "content": "This example demonstrates pull resistor configuration. | 1 2 3 4 . | // Configure pin as input with pull-down gpio.SetPinDirection(5, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Input); gpio.SetPullEnable(5, true); gpio.SetPullDirection(5, false); // Pull-down . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-4-pull-resistors",
    
    "relUrl": "/docs/examples/#example-4-pull-resistors"
  },"40": {
    "doc": "üí° Examples",
    "title": "Example 5: Drive Strength",
    "content": "This example shows drive strength configuration. | 1 2 3 . | // Set pin as output with reduced drive strength gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.SetDriveStrength(0, pcal95555::PCAL95555&lt;MyI2c&gt;::DriveStrength::Half); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#example-5-drive-strength",
    
    "relUrl": "/docs/examples/#example-5-drive-strength"
  },"41": {
    "doc": "üí° Examples",
    "title": "Running the Examples",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#running-the-examples",
    
    "relUrl": "/docs/examples/#running-the-examples"
  },"42": {
    "doc": "üí° Examples",
    "title": "ESP32",
    "content": "The examples are available in the examples/esp32 directory. | 1 2 . | cd examples/esp32 idf.py build flash monitor . | . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#esp32",
    
    "relUrl": "/docs/examples/#esp32"
  },"43": {
    "doc": "üí° Examples",
    "title": "Other Platforms",
    "content": "Adapt the I2C interface implementation for your platform (see Platform Integration) and compile with your platform‚Äôs toolchain. ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#other-platforms",
    
    "relUrl": "/docs/examples/#other-platforms"
  },"44": {
    "doc": "üí° Examples",
    "title": "Next Steps",
    "content": ". | Review the API Reference for method details | Check Troubleshooting if you encounter issues | Explore the examples directory for more examples | . Navigation ‚¨ÖÔ∏è API Reference | Next: Troubleshooting ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/examples/#next-steps",
    
    "relUrl": "/docs/examples/#next-steps"
  },"45": {
    "doc": "üí° Examples",
    "title": "üí° Examples",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/examples/",
    
    "relUrl": "/docs/examples/"
  },"46": {
    "doc": "üîå Hardware Setup",
    "title": "Hardware Setup",
    "content": "This guide covers the physical connections and hardware requirements for the PCAL9555A chip. ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#hardware-setup",
    
    "relUrl": "/docs/hardware_setup/#hardware-setup"
  },"47": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Connections",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#pin-connections",
    
    "relUrl": "/docs/hardware_setup/#pin-connections"
  },"48": {
    "doc": "üîå Hardware Setup",
    "title": "Basic I2C Connections",
    "content": "| 1 2 3 4 5 6 . | MCU PCAL9555A ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GND SCL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCL (with 4.7kŒ© pull-up to 3.3V) SDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDA (with 4.7kŒ© pull-up to 3.3V) . | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#basic-i2c-connections",
    
    "relUrl": "/docs/hardware_setup/#basic-i2c-connections"
  },"49": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Descriptions",
    "content": "| Pin | Name | Description | Required | . | VDD | Power | 1.65V to 5.5V power supply (typically 3.3V) | Yes | . | GND | Ground | Ground reference | Yes | . | SCL | Clock | I2C clock line | Yes | . | SDA | Data | I2C data line | Yes | . | A0-A2 | Address | I2C address selection pins | No (for single device) | . | INT | Interrupt | Interrupt output (optional) | No | . | RESET | Reset | Hardware reset (optional) | No | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#pin-descriptions",
    
    "relUrl": "/docs/hardware_setup/#pin-descriptions"
  },"50": {
    "doc": "üîå Hardware Setup",
    "title": "GPIO Pins",
    "content": "The PCAL9555A provides 16 GPIO pins organized into two ports: . | PORT_0: Pins 0-7 (P0.0 through P0.7) | PORT_1: Pins 8-15 (P1.0 through P1.7) | . Each pin can be configured as: . | Input or output | With or without pull-up/pull-down resistor | Push-pull or open-drain output (per port) | Interrupt enabled or disabled | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#gpio-pins",
    
    "relUrl": "/docs/hardware_setup/#gpio-pins"
  },"51": {
    "doc": "üîå Hardware Setup",
    "title": "Power Requirements",
    "content": ". | Supply Voltage: 1.65V to 5.5V (3.3V typical) | Current Consumption: . | Active: ~100 ¬µA typical | Standby: &lt; 1 ¬µA | . | Power Supply: Stable, low-noise supply recommended | Decoupling: 100 nF ceramic capacitor close to VDD pin recommended | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#power-requirements",
    
    "relUrl": "/docs/hardware_setup/#power-requirements"
  },"52": {
    "doc": "üîå Hardware Setup",
    "title": "I2C Configuration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#i2c-configuration",
    
    "relUrl": "/docs/hardware_setup/#i2c-configuration"
  },"53": {
    "doc": "üîå Hardware Setup",
    "title": "Address Configuration",
    "content": "The PCAL9555A I2C address is determined by pins A0-A2: . | A2 | A1 | A0 | I2C Address (7-bit) | . | 0 | 0 | 0 | 0x20 (default) | . | 0 | 0 | 1 | 0x21 | . | 0 | 1 | 0 | 0x22 | . | 0 | 1 | 1 | 0x23 | . | 1 | 0 | 0 | 0x24 | . | 1 | 0 | 1 | 0x25 | . | 1 | 1 | 0 | 0x26 | . | 1 | 1 | 1 | 0x27 | . Default: All address pins to GND = 0x20 (used in examples) . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#address-configuration",
    
    "relUrl": "/docs/hardware_setup/#address-configuration"
  },"54": {
    "doc": "üîå Hardware Setup",
    "title": "I2C Bus Configuration",
    "content": ". | Speed: Up to 400 kHz (Fast Mode) . | Standard Mode: 100 kHz | Fast Mode: 400 kHz (most common) | . | Pull-up Resistors: 4.7 kŒ© on SCL and SDA (required for I2C) | Bus Voltage: Must match VDD (typically 3.3V) | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#i2c-bus-configuration",
    
    "relUrl": "/docs/hardware_setup/#i2c-bus-configuration"
  },"55": {
    "doc": "üîå Hardware Setup",
    "title": "Physical Layout Recommendations",
    "content": ". | Trace Length: Keep I2C traces short (&lt; 10 cm recommended) | Ground Plane: Use a ground plane for noise reduction | Decoupling: Place 100 nF ceramic capacitor within 1 cm of VDD pin | Routing: Route clock and data lines away from noise sources | Multiple Devices: When using multiple expanders, use proper bus termination | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#physical-layout-recommendations",
    
    "relUrl": "/docs/hardware_setup/#physical-layout-recommendations"
  },"56": {
    "doc": "üîå Hardware Setup",
    "title": "Example Wiring Diagram",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#example-wiring-diagram",
    
    "relUrl": "/docs/hardware_setup/#example-wiring-diagram"
  },"57": {
    "doc": "üîå Hardware Setup",
    "title": "Single PCAL9555A",
    "content": "| 1 2 3 4 5 6 7 8 9 10 . | PCAL9555A ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ VDD ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ GND ‚îÇ SCL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SCL ‚îÇ‚îÄ‚îÄ‚îÄ 4.7kŒ© ‚îÄ‚îÄ‚îÄ 3.3V SDA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDA ‚îÇ‚îÄ‚îÄ‚îÄ 4.7kŒ© ‚îÄ‚îÄ‚îÄ 3.3V ‚îÇ ‚îÇ ‚îÇ P0.0-7 ‚îÇ‚îÄ‚îÄ‚îÄ GPIO pins (PORT_0) ‚îÇ P1.0-7 ‚îÇ‚îÄ‚îÄ‚îÄ GPIO pins (PORT_1) ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò . | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#single-pcal9555a",
    
    "relUrl": "/docs/hardware_setup/#single-pcal9555a"
  },"58": {
    "doc": "üîå Hardware Setup",
    "title": "Multiple PCAL9555A Devices",
    "content": "| 1 2 3 4 5 6 7 . | MCU SCL ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ PCAL9555A #1 (A0=0, Addr=0x20) SCL ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ PCAL9555A #2 (A0=1, Addr=0x21) SCL MCU SDA ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ PCAL9555A #1 SDA ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ PCAL9555A #2 SDA . | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#multiple-pcal9555a-devices",
    
    "relUrl": "/docs/hardware_setup/#multiple-pcal9555a-devices"
  },"59": {
    "doc": "üîå Hardware Setup",
    "title": "Interrupt Pin (Optional)",
    "content": "The INT pin provides hardware interrupt notification: . | Type: Open-drain output | Requires: External pull-up resistor (typically 10kŒ© to 3.3V) | Usage: Connect to a GPIO input on your MCU for interrupt-driven I/O | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#interrupt-pin-optional",
    
    "relUrl": "/docs/hardware_setup/#interrupt-pin-optional"
  },"60": {
    "doc": "üîå Hardware Setup",
    "title": "Reset Pin (Optional)",
    "content": "The RESET pin provides hardware reset: . | Type: Active-low input | Usage: Connect to MCU GPIO for software reset capability | Default: Leave floating (internal pull-up enables device) | . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#reset-pin-optional",
    
    "relUrl": "/docs/hardware_setup/#reset-pin-optional"
  },"61": {
    "doc": "üîå Hardware Setup",
    "title": "Next Steps",
    "content": ". | Verify connections with a multimeter | Use an I2C scanner to verify device detection at expected address | Proceed to Quick Start to test the connection | Review Platform Integration for software setup | . Navigation ‚¨ÖÔ∏è Quick Start | Next: Platform Integration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/#next-steps",
    
    "relUrl": "/docs/hardware_setup/#next-steps"
  },"62": {
    "doc": "üîå Hardware Setup",
    "title": "üîå Hardware Setup",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/hardware_setup/",
    
    "relUrl": "/docs/hardware_setup/"
  },"63": {
    "doc": "üìö Documentation",
    "title": "HF-PCAL95555 Documentation",
    "content": "Welcome! This directory contains step-by-step guides for installing, building, and using the HF-PCAL95555 library. ",
    "url": "/hf-pcal95555-driver/development/docs/#hf-pcal95555-documentation",
    
    "relUrl": "/docs/#hf-pcal95555-documentation"
  },"64": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation Structure",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/#-documentation-structure",
    
    "relUrl": "/docs/#-documentation-structure"
  },"65": {
    "doc": "üìö Documentation",
    "title": "Getting Started",
    "content": ". | üõ†Ô∏è Installation ‚Äì How to integrate the driver into your project | ‚ö° Quick Start ‚Äì Minimal working example to get you running | üîå Hardware Setup ‚Äì Wiring diagrams and pin connections | . ",
    "url": "/hf-pcal95555-driver/development/docs/#getting-started",
    
    "relUrl": "/docs/#getting-started"
  },"66": {
    "doc": "üìö Documentation",
    "title": "Integration",
    "content": ". | üîß Platform Integration ‚Äì Implement the CRTP I2C interface for your platform | ‚öôÔ∏è Configuration ‚Äì Configuration options and Kconfig settings | . ",
    "url": "/hf-pcal95555-driver/development/docs/#integration",
    
    "relUrl": "/docs/#integration"
  },"67": {
    "doc": "üìö Documentation",
    "title": "Reference",
    "content": ". | üìñ API Reference ‚Äì Complete API documentation | üí° Examples ‚Äì Detailed example walkthroughs | . ",
    "url": "/hf-pcal95555-driver/development/docs/#reference",
    
    "relUrl": "/docs/#reference"
  },"68": {
    "doc": "üìö Documentation",
    "title": "Troubleshooting",
    "content": ". | üêõ Troubleshooting ‚Äì Common issues and solutions | . ",
    "url": "/hf-pcal95555-driver/development/docs/#troubleshooting",
    
    "relUrl": "/docs/#troubleshooting"
  },"69": {
    "doc": "üìö Documentation",
    "title": "üöÄ Quick Start Path",
    "content": "New to PCAL95555? Follow this recommended path: . | Start with Installation to integrate the driver | Follow Hardware Setup to wire your I/O expander | Read Quick Start for a minimal working example | Check Platform Integration to implement the I2C interface | Explore Examples for more advanced usage | . ",
    "url": "/hf-pcal95555-driver/development/docs/#-quick-start-path",
    
    "relUrl": "/docs/#-quick-start-path"
  },"70": {
    "doc": "üìö Documentation",
    "title": "üí° Need Help?",
    "content": ". | üêõ Found a bug? Check the Troubleshooting guide | ‚ùì Have questions? Review the API Reference | üìù Want to contribute? See the contributing guidelines in the main README | . Navigation ‚û°Ô∏è Installation . ",
    "url": "/hf-pcal95555-driver/development/docs/#-need-help",
    
    "relUrl": "/docs/#-need-help"
  },"71": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/",
    
    "relUrl": "/docs/"
  },"72": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Installation",
    "content": "This guide covers how to integrate the PCAL95555 driver into your project. ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#installation",
    
    "relUrl": "/docs/installation/#installation"
  },"73": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Prerequisites",
    "content": "Before installing the driver, ensure you have: . | C++11 Compiler: GCC 4.8+, Clang 3.3+, or MSVC 2013+ | I2C Interface: Your platform‚Äôs I2C driver (ESP-IDF, STM32 HAL, Arduino Wire, etc.) | . ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#prerequisites",
    
    "relUrl": "/docs/installation/#prerequisites"
  },"74": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Integration",
    "content": "This driver is a header-only template library designed to be integrated directly into your project. There‚Äôs no separate build step required. ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#integration",
    
    "relUrl": "/docs/installation/#integration"
  },"75": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 1: Copy Files",
    "content": "Copy the following files into your project: . | 1 2 3 4 . | inc/ ‚îî‚îÄ‚îÄ pcal95555.hpp src/ ‚îî‚îÄ‚îÄ pcal95555.cpp . | . Note: The driver uses a header-only template design where pcal95555.cpp is included by pcal95555.hpp. You typically only need to include the header file in your project. ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#option-1-copy-files",
    
    "relUrl": "/docs/installation/#option-1-copy-files"
  },"76": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 2: Git Submodule",
    "content": "| 1 2 . | cd your-project git submodule add https://github.com/N3b3x/hf-pcal95555-driver.git drivers/pcal95555 . | . Then add to your include path: . | 1 . | target_include_directories(your_target PRIVATE drivers/pcal95555/inc) . | . ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#option-2-git-submodule",
    
    "relUrl": "/docs/installation/#option-2-git-submodule"
  },"77": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Including the Header",
    "content": "Simply include the header in your code: . | 1 . | #include \"pcal95555.hpp\" . | . The implementation is included automatically via the header file. ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#including-the-header",
    
    "relUrl": "/docs/installation/#including-the-header"
  },"78": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Next Steps",
    "content": ". | Follow the Quick Start guide to create your first application | Review Hardware Setup for wiring instructions | Check Platform Integration to implement the I2C interface | . Navigation ‚¨ÖÔ∏è Back to Index | Next: Quick Start ‚û°Ô∏è . ",
    "url": "/hf-pcal95555-driver/development/docs/installation/#next-steps",
    
    "relUrl": "/docs/installation/#next-steps"
  },"79": {
    "doc": "üõ†Ô∏è Installation",
    "title": "üõ†Ô∏è Installation",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/installation/",
    
    "relUrl": "/docs/installation/"
  },"80": {
    "doc": "üîß Platform Integration",
    "title": "Platform Integration Guide",
    "content": "This guide explains how to implement the hardware abstraction interface for the PCAL95555 driver on your platform. ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#platform-integration-guide",
    
    "relUrl": "/docs/platform_integration/#platform-integration-guide"
  },"81": {
    "doc": "üîß Platform Integration",
    "title": "Understanding CRTP (Curiously Recurring Template Pattern)",
    "content": "The PCAL95555 driver uses CRTP (Curiously Recurring Template Pattern) for hardware abstraction. This design choice provides several critical benefits for embedded systems: . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern",
    
    "relUrl": "/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern"
  },"82": {
    "doc": "üîß Platform Integration",
    "title": "Why CRTP Instead of Virtual Functions?",
    "content": "1. Zero Runtime Overhead . | Virtual functions: Require a vtable lookup (indirect call) = ~5-10 CPU cycles overhead per call | CRTP: Direct function calls = 0 overhead, compiler can inline | Impact: In time-critical embedded code, this matters significantly | . 2. Compile-Time Polymorphism . | Virtual functions: Runtime dispatch - the compiler cannot optimize across the abstraction boundary | CRTP: Compile-time dispatch - full optimization, dead code elimination, constant propagation | Impact: Smaller code size, faster execution | . 3. Memory Efficiency . | Virtual functions: Each object needs a vtable pointer (4-8 bytes) | CRTP: No vtable pointer needed | Impact: Critical in memory-constrained systems (many MCUs have &lt;64KB RAM) | . 4. Type Safety . | Virtual functions: Runtime errors if method not implemented | CRTP: Compile-time errors if method not implemented | Impact: Catch bugs at compile time, not in the field | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#why-crtp-instead-of-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#why-crtp-instead-of-virtual-functions"
  },"83": {
    "doc": "üîß Platform Integration",
    "title": "How CRTP Works",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 . | // Base template class (from pcal95555.hpp) template &lt;typename Derived&gt; class I2cInterface { public: bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // Cast 'this' to Derived* and call the derived implementation return static_cast&lt;Derived*&gt;(this)-&gt;write(addr, reg, data, len); } bool read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { return static_cast&lt;Derived*&gt;(this)-&gt;read(addr, reg, data, len); } }; // Your implementation class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: // This method is called directly (no virtual overhead) bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // Your platform-specific I2C code } bool read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { // Your platform-specific I2C code } }; . | . The key insight: static_cast&lt;Derived*&gt;(this) allows the base class to call methods on the derived class at compile time, not runtime. ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#how-crtp-works",
    
    "relUrl": "/docs/platform_integration/#how-crtp-works"
  },"84": {
    "doc": "üîß Platform Integration",
    "title": "Performance Comparison",
    "content": "| Aspect | Virtual Functions | CRTP | . | Function call overhead | ~5-10 cycles | 0 cycles (inlined) | . | Code size | Larger (vtables) | Smaller (optimized) | . | Memory per object | +4-8 bytes (vptr) | 0 bytes | . | Compile-time checks | No | Yes | . | Optimization | Limited | Full | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#performance-comparison",
    
    "relUrl": "/docs/platform_integration/#performance-comparison"
  },"85": {
    "doc": "üîß Platform Integration",
    "title": "Interface Definition",
    "content": "The PCAL95555 driver requires you to implement the I2cInterface template: . Location: inc/pcal95555.hpp#L437 . | 1 2 3 4 5 6 7 . | template &lt;typename Derived&gt; class I2cInterface { public: // Required methods (implement both) bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len); bool read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len); }; . | . Method Requirements: . | write(): Write len bytes from data to register reg at I2C address addr (7-bit address) | read(): Read len bytes into data from register reg at I2C address addr (7-bit address) | Both return true on success, false on failure (NACK, timeout, etc.) | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#interface-definition",
    
    "relUrl": "/docs/platform_integration/#interface-definition"
  },"86": {
    "doc": "üîß Platform Integration",
    "title": "Implementation Steps",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#implementation-steps",
    
    "relUrl": "/docs/platform_integration/#implementation-steps"
  },"87": {
    "doc": "üîß Platform Integration",
    "title": "Step 1: Create Your Implementation Class",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 . | #include \"pcal95555.hpp\" class MyPlatformI2c : public pcal95555::I2cInterface&lt;MyPlatformI2c&gt; { private: // Your platform-specific members i2c_handle_t i2c_handle_; public: // Constructor MyPlatformI2c(i2c_handle_t handle) : i2c_handle_(handle) {} // Implement required methods (NO virtual keyword!) bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // Your I2C write implementation return true; } bool read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { // Your I2C read implementation return true; } }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#step-1-create-your-implementation-class",
    
    "relUrl": "/docs/platform_integration/#step-1-create-your-implementation-class"
  },"88": {
    "doc": "üîß Platform Integration",
    "title": "Step 2: Platform-Specific Examples",
    "content": "ESP32 (ESP-IDF) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . | #include \"driver/i2c.h\" #include \"pcal95555.hpp\" class Esp32I2cBus : public pcal95555::I2cInterface&lt;Esp32I2cBus&gt; { public: bool write(uint8_t addr, uint8_t reg, const uint8_t* data, size_t len) { i2c_cmd_handle_t cmd = i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, reg, true); i2c_master_write(cmd, (uint8_t*)data, len, true); i2c_master_stop(cmd); esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); return ret == ESP_OK; } bool read(uint8_t addr, uint8_t reg, uint8_t* data, size_t len) { i2c_cmd_handle_t cmd = i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, reg, true); i2c_master_start(cmd); i2c_master_write_byte(cmd, (addr &lt;&lt; 1) | I2C_MASTER_READ, true); i2c_master_read(cmd, data, len, I2C_MASTER_LAST_NACK); i2c_master_stop(cmd); esp_err_t ret = i2c_master_cmd_begin(I2C_NUM_0, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); return ret == ESP_OK; } }; . | . STM32 (HAL) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 . | #include \"stm32f4xx_hal.h\" #include \"pcal95555.hpp\" extern I2C_HandleTypeDef hi2c1; class STM32I2cBus : public pcal95555::I2cInterface&lt;STM32I2cBus&gt; { public: bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // STM32 HAL uses 8-bit address (7-bit &lt;&lt; 1) return HAL_I2C_Mem_Write(&amp;hi2c1, addr &lt;&lt; 1, reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)data, len, HAL_MAX_DELAY) == HAL_OK; } bool read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { return HAL_I2C_Mem_Read(&amp;hi2c1, addr &lt;&lt; 1, reg, I2C_MEMADD_SIZE_8BIT, data, len, HAL_MAX_DELAY) == HAL_OK; } }; . | . Arduino . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 . | #include &lt;Wire.h&gt; #include \"pcal95555.hpp\" class ArduinoI2cBus : public pcal95555::I2cInterface&lt;ArduinoI2cBus&gt; { public: bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { Wire.beginTransmission(addr); Wire.write(reg); Wire.write(data, len); return Wire.endTransmission() == 0; } bool read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { Wire.beginTransmission(addr); Wire.write(reg); if (Wire.endTransmission(false) != 0) return false; Wire.requestFrom(addr, len); for (size_t i = 0; i &lt; len &amp;&amp; Wire.available(); i++) { data[i] = Wire.read(); } return true; } }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#step-2-platform-specific-examples",
    
    "relUrl": "/docs/platform_integration/#step-2-platform-specific-examples"
  },"89": {
    "doc": "üîß Platform Integration",
    "title": "Common Pitfalls",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#common-pitfalls",
    
    "relUrl": "/docs/platform_integration/#common-pitfalls"
  },"90": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Use Virtual Functions",
    "content": "| 1 2 3 4 5 6 7 . | // WRONG - defeats the purpose of CRTP class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: virtual bool write(...) override { // ‚ùå Virtual keyword not needed // ... } }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#-dont-use-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#-dont-use-virtual-functions"
  },"91": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct CRTP Implementation",
    "content": "| 1 2 3 4 5 6 7 . | // CORRECT - no virtual keyword class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: bool write(...) { // ‚úÖ Direct implementation // ... } }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#-correct-crtp-implementation",
    
    "relUrl": "/docs/platform_integration/#-correct-crtp-implementation"
  },"92": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Forget the Template Parameter",
    "content": "| 1 2 3 4 . | // WRONG - missing template parameter class MyI2c : public pcal95555::I2cInterface { // ‚ùå Compiler error // ... }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#-dont-forget-the-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-dont-forget-the-template-parameter"
  },"93": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct Template Parameter",
    "content": "| 1 2 3 4 . | // CORRECT - pass your class as template parameter class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { // ‚úÖ // ... }; . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#-correct-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-correct-template-parameter"
  },"94": {
    "doc": "üîß Platform Integration",
    "title": "Testing Your Implementation",
    "content": "After implementing the interface, test it: . | 1 2 3 4 5 6 7 8 . | MyPlatformI2c i2c; pcal95555::PCAL95555&lt;MyPlatformI2c&gt; gpio(&amp;i2c, 0x20); gpio.ResetToDefault(); gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyPlatformI2c&gt;::GPIODir::Output); gpio.WritePin(0, true); bool value = gpio.ReadPin(1); // Interface works! . | . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#testing-your-implementation",
    
    "relUrl": "/docs/platform_integration/#testing-your-implementation"
  },"95": {
    "doc": "üîß Platform Integration",
    "title": "Next Steps",
    "content": ". | See Configuration for driver configuration options | Check Examples for complete usage examples | Review API Reference for all available methods | . Navigation ‚¨ÖÔ∏è Hardware Setup | Next: Configuration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/#next-steps",
    
    "relUrl": "/docs/platform_integration/#next-steps"
  },"96": {
    "doc": "üîß Platform Integration",
    "title": "üîß Platform Integration",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/platform_integration/",
    
    "relUrl": "/docs/platform_integration/"
  },"97": {
    "doc": "‚ö° Quick Start",
    "title": "Quick Start",
    "content": "This guide will get you up and running with the PCAL95555 driver in just a few steps. ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#quick-start",
    
    "relUrl": "/docs/quickstart/#quick-start"
  },"98": {
    "doc": "‚ö° Quick Start",
    "title": "Prerequisites",
    "content": ". | Driver installed | Hardware wired | I2C interface implemented | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#prerequisites",
    
    "relUrl": "/docs/quickstart/#prerequisites"
  },"99": {
    "doc": "‚ö° Quick Start",
    "title": "Minimal Example",
    "content": "Here‚Äôs a complete working example: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 . | #include \"pcal95555.hpp\" // 1. Implement the I2C interface class MyI2c : public pcal95555::I2cInterface&lt;MyI2c&gt; { public: bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { // Your I2C write implementation return true; } bool read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) { // Your I2C read implementation return true; } }; // 2. Create instances MyI2c i2c; pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); // 0x20 is default I2C address // 3. Initialize gpio.ResetToDefault(); // all pins become inputs with pull-ups // 4. Configure and use gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); gpio.WritePin(0, true); bool input = gpio.ReadPin(1); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#minimal-example",
    
    "relUrl": "/docs/quickstart/#minimal-example"
  },"100": {
    "doc": "‚ö° Quick Start",
    "title": "Step-by-Step Explanation",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-by-step-explanation",
    
    "relUrl": "/docs/quickstart/#step-by-step-explanation"
  },"101": {
    "doc": "‚ö° Quick Start",
    "title": "Step 1: Include the Header",
    "content": "| 1 . | #include \"pcal95555.hpp\" . | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-1-include-the-header",
    
    "relUrl": "/docs/quickstart/#step-1-include-the-header"
  },"102": {
    "doc": "‚ö° Quick Start",
    "title": "Step 2: Implement the I2C Interface",
    "content": "You need to implement the I2cInterface for your platform. See Platform Integration for detailed examples for ESP32, STM32, and Arduino. The interface requires two methods: . | write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) - Write data to a register | read(uint8_t addr, uint8_t reg, uint8_t *data, size_t len) - Read data from a register | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-2-implement-the-i2c-interface",
    
    "relUrl": "/docs/quickstart/#step-2-implement-the-i2c-interface"
  },"103": {
    "doc": "‚ö° Quick Start",
    "title": "Step 3: Create Driver Instance",
    "content": "| 1 2 . | MyI2c i2c; pcal95555::PCAL95555&lt;MyI2c&gt; gpio(&amp;i2c, 0x20); . | . The constructor takes: . | Pointer to your I2C interface implementation | I2C address (0x20 is the default, can be changed via A0-A2 pins) | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-3-create-driver-instance",
    
    "relUrl": "/docs/quickstart/#step-3-create-driver-instance"
  },"104": {
    "doc": "‚ö° Quick Start",
    "title": "Step 4: Initialize",
    "content": "| 1 . | gpio.ResetToDefault(); . | . ResetToDefault() puts the device in a known state (all pins as inputs with pull-ups enabled). ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-4-initialize",
    
    "relUrl": "/docs/quickstart/#step-4-initialize"
  },"105": {
    "doc": "‚ö° Quick Start",
    "title": "Step 5: Configure and Use Pins",
    "content": "| 1 2 3 4 5 6 7 8 . | // Set pin 0 as output gpio.SetPinDirection(0, pcal95555::PCAL95555&lt;MyI2c&gt;::GPIODir::Output); // Write to pin 0 gpio.WritePin(0, true); // Read from pin 1 (input) bool value = gpio.ReadPin(1); . | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#step-5-configure-and-use-pins",
    
    "relUrl": "/docs/quickstart/#step-5-configure-and-use-pins"
  },"106": {
    "doc": "‚ö° Quick Start",
    "title": "Expected Output",
    "content": "When running this example: . | Pin 0 should be set high (if connected to an LED, it should light up) | Pin 1 value should be read correctly | No error messages should appear | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#expected-output",
    
    "relUrl": "/docs/quickstart/#expected-output"
  },"107": {
    "doc": "‚ö° Quick Start",
    "title": "Troubleshooting",
    "content": "If you encounter issues: . | Compilation errors: Check that you‚Äôve implemented all required I2C interface methods | Initialization fails: Verify hardware connections and I2C address | No response: Check I2C bus and pull-up resistors | See: Troubleshooting for common issues | . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#troubleshooting",
    
    "relUrl": "/docs/quickstart/#troubleshooting"
  },"108": {
    "doc": "‚ö° Quick Start",
    "title": "Next Steps",
    "content": ". | Explore Examples for more advanced usage | Review the API Reference for all available methods | Check Configuration for customization options | . Navigation ‚¨ÖÔ∏è Installation | Next: Hardware Setup ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/#next-steps",
    
    "relUrl": "/docs/quickstart/#next-steps"
  },"109": {
    "doc": "‚ö° Quick Start",
    "title": "‚ö° Quick Start",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/quickstart/",
    
    "relUrl": "/docs/quickstart/"
  },"110": {
    "doc": "üêõ Troubleshooting",
    "title": "Troubleshooting",
    "content": "This guide helps you diagnose and resolve common issues when using the PCAL95555 driver. ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#troubleshooting",
    
    "relUrl": "/docs/troubleshooting/#troubleshooting"
  },"111": {
    "doc": "üêõ Troubleshooting",
    "title": "Common Error Messages",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#common-error-messages",
    
    "relUrl": "/docs/troubleshooting/#common-error-messages"
  },"112": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Device Not Detected",
    "content": "Symptoms: . | ResetToDefault() or other operations fail | No response from device | . Causes: . | Wrong I2C address | Hardware connections incorrect | Pull-up resistors missing | . Solutions: . | Check I2C address: . | Default is 0x20 (all A0-A2 pins to GND) | Use I2C scanner to verify device address | Update address in constructor if different | . | Verify hardware connections: . | Check SDA/SCL connections | Verify 4.7kŒ© pull-up resistors on SCL and SDA | Ensure power connections (VDD and GND) | . | Test I2C bus: . | Verify I2C bus is properly initialized | Check I2C bus speed (try 100 kHz if 400 kHz fails) | . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-device-not-detected",
    
    "relUrl": "/docs/troubleshooting/#error-device-not-detected"
  },"113": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Invalid Pin",
    "content": "Symptoms: . | Methods return false | Pin operations fail | . Causes: . | Pin number &gt;= 16 | Invalid pin parameter | . Solutions: . | 1 2 3 4 . | // Valid pins are 0-15 if (pin &lt; 16) { gpio.SetPinDirection(pin, dir); } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-invalid-pin",
    
    "relUrl": "/docs/troubleshooting/#error-invalid-pin"
  },"114": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: I2C Communication Failures",
    "content": "Symptoms: . | Operations fail intermittently | Timeout errors | . Solutions: . | Increase retries: | 1 . | gpio.SetRetries(3); // Default is 0 . | . | Check bus speed: Reduce I2C speed if using long wires . | Verify signal integrity: Check for noise on I2C lines | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#error-i2c-communication-failures",
    
    "relUrl": "/docs/troubleshooting/#error-i2c-communication-failures"
  },"115": {
    "doc": "üêõ Troubleshooting",
    "title": "Hardware Issues",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#hardware-issues",
    
    "relUrl": "/docs/troubleshooting/#hardware-issues"
  },"116": {
    "doc": "üêõ Troubleshooting",
    "title": "Device Not Responding",
    "content": "Symptoms: . | No response to I2C commands | Initialization fails | . Checklist: . | Verify power supply voltage (1.65V-5.5V) | Check all connections are secure | Verify pull-up resistors (4.7kŒ©) on SCL and SDA | Check I2C address configuration (A0-A2 pins) | Use I2C scanner to detect device address | Verify ground connection | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#device-not-responding",
    
    "relUrl": "/docs/troubleshooting/#device-not-responding"
  },"117": {
    "doc": "üêõ Troubleshooting",
    "title": "Incorrect Pin States",
    "content": "Symptoms: . | Pins don‚Äôt respond to writes | Reads return wrong values | . Checklist: . | Verify pin direction is set correctly | Check pin is configured as output before writing | Verify pull resistors are configured if needed | Check for external loads affecting pin state | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#incorrect-pin-states",
    
    "relUrl": "/docs/troubleshooting/#incorrect-pin-states"
  },"118": {
    "doc": "üêõ Troubleshooting",
    "title": "Software Issues",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#software-issues",
    
    "relUrl": "/docs/troubleshooting/#software-issues"
  },"119": {
    "doc": "üêõ Troubleshooting",
    "title": "Compilation Errors",
    "content": "Error: ‚ÄúNo matching function‚Äù . Solution: . | Ensure you‚Äôve implemented all required I2cInterface methods | Check method signatures match exactly | . Error: ‚ÄúUndefined reference‚Äù . Solution: . | Verify you‚Äôre including the header file | Check include paths are correct | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#compilation-errors",
    
    "relUrl": "/docs/troubleshooting/#compilation-errors"
  },"120": {
    "doc": "üêõ Troubleshooting",
    "title": "Runtime Errors",
    "content": "Initialization Fails . Checklist: . | I2C interface is properly implemented | I2C bus is initialized | Hardware connections are correct | I2C address matches hardware configuration | . Pin Operations Fail . Checklist: . | Pin number is valid (0-15) | Pin direction is set correctly | I2C communication is working | Error flags are checked | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#runtime-errors",
    
    "relUrl": "/docs/troubleshooting/#runtime-errors"
  },"121": {
    "doc": "üêõ Troubleshooting",
    "title": "Debugging Tips",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#debugging-tips",
    
    "relUrl": "/docs/troubleshooting/#debugging-tips"
  },"122": {
    "doc": "üêõ Troubleshooting",
    "title": "Enable Debug Output",
    "content": "Add debug prints to your I2C interface: . | 1 2 3 4 5 6 7 . | bool write(uint8_t addr, uint8_t reg, const uint8_t *data, size_t len) { printf(\"I2C Write: addr=0x%02X, reg=0x%02X, len=%zu\\n\", addr, reg, len); // ... your implementation bool result = /* ... */; printf(\"Result: %s\\n\", result ? \"OK\" : \"FAIL\"); return result; } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#enable-debug-output",
    
    "relUrl": "/docs/troubleshooting/#enable-debug-output"
  },"123": {
    "doc": "üêõ Troubleshooting",
    "title": "Check Error Flags",
    "content": "| 1 2 3 . | gpio.ClearErrorFlags(); // Clear all errors // Perform operation // Check if errors occurred . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#check-error-flags",
    
    "relUrl": "/docs/troubleshooting/#check-error-flags"
  },"124": {
    "doc": "üêõ Troubleshooting",
    "title": "Use I2C Scanner",
    "content": "Scan the I2C bus to verify device detection: . | 1 2 3 4 5 6 7 8 . | void i2c_scanner() { for (uint8_t addr = 0x08; addr &lt; 0x78; addr++) { // Try to communicate with address if (/* device responds */) { printf(\"Device found at 0x%02X\\n\", addr); } } } . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#use-i2c-scanner",
    
    "relUrl": "/docs/troubleshooting/#use-i2c-scanner"
  },"125": {
    "doc": "üêõ Troubleshooting",
    "title": "FAQ",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#faq",
    
    "relUrl": "/docs/troubleshooting/#faq"
  },"126": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Why do my pin writes not work?",
    "content": "A: Common causes: . | Pin not configured as output: Call SetPinDirection(pin, GPIODir::Output) first | Wrong pin number: Valid pins are 0-15 | I2C communication failure: Check I2C bus and connections | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-why-do-my-pin-writes-not-work",
    
    "relUrl": "/docs/troubleshooting/#q-why-do-my-pin-writes-not-work"
  },"127": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: How do I use interrupts?",
    "content": "A: . | Configure pin as input | Enable input latching: EnableInputLatch(pin, true) | Configure interrupt mask: ConfigureInterruptMask(~(1 &lt;&lt; pin)) | Set callback: SetInterruptCallback(callback) | Call HandleInterrupt() when interrupt occurs | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-how-do-i-use-interrupts",
    
    "relUrl": "/docs/troubleshooting/#q-how-do-i-use-interrupts"
  },"128": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Can I use multiple PCAL9555A devices?",
    "content": "A: Yes! Configure different I2C addresses via A0-A2 pins, then create separate driver instances: . | 1 2 . | pcal95555::PCAL95555&lt;MyI2c&gt; gpio1(&amp;i2c, 0x20); // First device pcal95555::PCAL95555&lt;MyI2c&gt; gpio2(&amp;i2c, 0x21); // Second device . | . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-can-i-use-multiple-pcal9555a-devices",
    
    "relUrl": "/docs/troubleshooting/#q-can-i-use-multiple-pcal9555a-devices"
  },"129": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What‚Äôs the difference between pull-up and pull-down?",
    "content": "A: . | Pull-up: Resistor connects pin to VDD (default high when floating) | Pull-down: Resistor connects pin to GND (default low when floating) | . Choose based on your circuit requirements. ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#q-whats-the-difference-between-pull-up-and-pull-down",
    
    "relUrl": "/docs/troubleshooting/#q-whats-the-difference-between-pull-up-and-pull-down"
  },"130": {
    "doc": "üêõ Troubleshooting",
    "title": "Getting More Help",
    "content": "If you‚Äôre still experiencing issues: . | Check the API Reference for method details | Review Examples for working code | Search existing issues on GitHub | Open a new issue with: . | Description of the problem | Steps to reproduce | Hardware setup details | Error messages/logs | I2C bus analyzer output (if available) | . | . Navigation ‚¨ÖÔ∏è Examples | Back to Index . ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/#getting-more-help",
    
    "relUrl": "/docs/troubleshooting/#getting-more-help"
  },"131": {
    "doc": "üêõ Troubleshooting",
    "title": "üêõ Troubleshooting",
    "content": " ",
    "url": "/hf-pcal95555-driver/development/docs/troubleshooting/",
    
    "relUrl": "/docs/troubleshooting/"
  },"132": {
    "doc": "API Reference",
    "title": "API Reference",
    "content": "# API Reference Complete reference documentation for all public methods and types in the PCAL95555 driver. ## Source Code - **Main Header**: [`inc/pcal95555.hpp`](../inc/pcal95555.hpp) - **Implementation**: [`src/pcal95555.cpp`](../src/pcal95555.cpp) ## Core Class ### `PCAL95555` Main driver class for interfacing with the PCAL9555A I/O expander. **Template Parameter**: `I2cType` - Your I2C interface implementation (must inherit from `pcal95555::I2cInterface`) **Location**: [`inc/pcal95555.hpp`](../inc/pcal95555.hpp) **Constructor:** ```cpp PCAL95555(I2cType* bus, uint8_t address); ``` **Location**: [`inc/pcal95555.hpp`](../inc/pcal95555.hpp) ## Methods ### Initialization | Method | Signature | Location |--------|-----------|----------| `ResetToDefault()` | `void ResetToDefault()` | [`src/pcal95555.cpp#L49`](../src/pcal95555.cpp#L49) | `InitFromConfig()` | `void InitFromConfig()` | [`src/pcal95555.cpp#L78`](../src/pcal95555.cpp#L78) | ### Pin Direction | Method | Signature | Location |--------|-----------|----------| `SetPinDirection()` | `bool SetPinDirection(uint16_t pin, GPIODir dir)` | [`src/pcal95555.cpp#L110`](../src/pcal95555.cpp#L110) | `SetMultipleDirections()` | `bool SetMultipleDirections(uint16_t mask, GPIODir dir)` | [`src/pcal95555.cpp#L552`](../src/pcal95555.cpp#L552) | ### Pin I/O | Method | Signature | Location |--------|-----------|----------| `ReadPin()` | `bool ReadPin(uint16_t pin)` | [`src/pcal95555.cpp#L560`](../src/pcal95555.cpp#L560) | `WritePin()` | `bool WritePin(uint16_t pin, bool value)` | [`src/pcal95555.cpp#L569`](../src/pcal95555.cpp#L569) | `TogglePin()` | `bool TogglePin(uint16_t pin)` | [`src/pcal95555.cpp#L577`](../src/pcal95555.cpp#L577) | ### Pull-up/Pull-down | Method | Signature | Location |--------|-----------|----------| `SetPullEnable()` | `bool SetPullEnable(uint16_t pin, bool enable)` | [`src/pcal95555.cpp#L586`](../src/pcal95555.cpp#L586) | `SetPullDirection()` | `bool SetPullDirection(uint16_t pin, bool pull_up)` | [`src/pcal95555.cpp#L594`](../src/pcal95555.cpp#L594) | ### Drive Strength | Method | Signature | Location |--------|-----------|----------| `SetDriveStrength()` | `bool SetDriveStrength(uint16_t pin, DriveStrength level)` | [`src/pcal95555.cpp#L603`](../src/pcal95555.cpp#L603) | ### Interrupts | Method | Signature | Location |--------|-----------|----------| `ConfigureInterruptMask()` | `bool ConfigureInterruptMask(uint16_t mask)` | [`src/pcal95555.cpp#L611`](../src/pcal95555.cpp#L611) | `GetInterruptStatus()` | `uint16_t GetInterruptStatus()` | [`src/pcal95555.cpp#L617`](../src/pcal95555.cpp#L617) | `SetInterruptCallback()` | `void SetInterruptCallback(const std::function& callback)` | [`src/pcal95555.cpp#L668`](../src/pcal95555.cpp#L668) | `HandleInterrupt()` | `void HandleInterrupt()` | [`src/pcal95555.cpp#L675`](../src/pcal95555.cpp#L675) | ### Output Mode | Method | Signature | Location |--------|-----------|----------| `SetOutputMode()` | `bool SetOutputMode(bool port_0_open_drain, bool port_1_open_drain)` | [`src/pcal95555.cpp#L626`](../src/pcal95555.cpp#L626) | ### Polarity | Method | Signature | Location |--------|-----------|----------| `SetPinPolarity()` | `bool SetPinPolarity(uint16_t pin, Polarity polarity)` | [`src/pcal95555.cpp#L635`](../src/pcal95555.cpp#L635) | `SetMultiplePolarities()` | `bool SetMultiplePolarities(uint16_t mask, Polarity polarity)` | [`src/pcal95555.cpp#L644`](../src/pcal95555.cpp#L644) | ### Input Latch | Method | Signature | Location |--------|-----------|----------| `EnableInputLatch()` | `bool EnableInputLatch(uint16_t pin, bool enable)` | [`src/pcal95555.cpp#L653`](../src/pcal95555.cpp#L653) | `EnableMultipleInputLatches()` | `bool EnableMultipleInputLatches(uint16_t mask, bool enable)` | [`src/pcal95555.cpp#L662`](../src/pcal95555.cpp#L662) | ### Error Handling | Method | Signature | Location |--------|-----------|----------| `SetRetries()` | `void SetRetries(int retries)` | [`inc/pcal95555.hpp#L503`](../inc/pcal95555.hpp#L503) | `GetErrorFlags()` | `uint16_t GetErrorFlags() const` | [`inc/pcal95555.hpp#L510`](../inc/pcal95555.hpp#L510) | `ClearErrorFlags()` | `void ClearErrorFlags(uint16_t mask = 0xFFFF)` | [`inc/pcal95555.hpp#L517`](../inc/pcal95555.hpp#L517) | ## Types ### Enumerations | Type | Values | Location |------|--------|----------| `GPIODir` | `Input`, `Output` | [`inc/pcal95555.hpp`](../inc/pcal95555.hpp) | `DriveStrength` | `Level0`, `Level1`, `Level2`, `Level3` | [`inc/pcal95555.hpp`](../inc/pcal95555.hpp) | `Polarity` | `Normal`, `Inverted` | [`inc/pcal95555.hpp`](../inc/pcal95555.hpp) | --- **Navigation** ‚¨ÖÔ∏è [Configuration](/hf-pcal95555-driver/development/docs/configuration/) | [Next: Examples ‚û°Ô∏è](/hf-pcal95555-driver/development/docs/examples/) | [Back to Index](/hf-pcal95555-driver/development/docs/) ",
    "url": "/hf-pcal95555-driver/development/docs/api_reference.html",
    
    "relUrl": "/docs/api_reference.html"
  },"133": {
    "doc": "PCAL9555 ESP32-C6 Comprehensive Test Suite",
    "title": "PCAL9555 ESP32-C6 Comprehensive Test Suite",
    "content": "# PCAL9555 ESP32-C6 Comprehensive Test Suite This directory contains comprehensive test suites for the PCAL9555 16-bit I/O expander driver using the ESP32-C6 DevKit-M-1. ## üìã Table of Contents - [Hardware Overview](#-hardware-overview) - [Pin Connections](#-pin-connections) - [Hardware Setup](#-hardware-setup) - [Building the Tests](#-building-the-tests) - [Running the Tests](#-running-the-tests) - [Test Suites](#-test-suites) - [Troubleshooting](#-troubleshooting) --- ## üîå Hardware Overview ### ESP32-C6 DevKit-M-1 The ESP32-C6 DevKit-M-1 serves as the host controller for communicating with the PCAL9555 GPIO expander via I2C. ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ESP32-C6 DevKit-M-1 ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ESP32-C6 Microcontroller ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ GPIO Pins: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ I2C: SDA (GPIO4), SCL (GPIO5) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Test Indicator: GPIO14 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ USB-C Connector ‚îÇ ‚îÇ (Power + Serial Communication) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` ### PCAL9555 GPIO Expander The PCAL9555 is a 16-bit I/O expander with I¬≤C interface, providing 16 GPIO pins organized into two 8-bit ports. ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ PCAL9555 GPIO Expander ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ PCAL9555 IC ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Features: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ 16 GPIO pins (PORT_0: P0.0-P0.7) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ 16 GPIO pins (PORT_1: P1.0-P1.7) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ I2C interface (7-bit address) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Configurable pull-up/pull-down ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Programmable drive strength ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Interrupt support ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Input latch capability ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Polarity inversion ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Open-drain output mode ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ I2C Connections: ‚îÇ ‚îÇ ‚Ä¢ SDA (I2C Data) ‚îÇ ‚îÇ ‚Ä¢ SCL (I2C Clock) ‚îÇ ‚îÇ ‚Ä¢ VDD (3.3V Power) ‚îÇ ‚îÇ ‚Ä¢ GND (Ground) ‚îÇ ‚îÇ ‚Ä¢ INT (Interrupt Output, optional) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` --- ## üìå Pin Connections ### I2C Bus Connections | PCAL9555 Pin | ESP32-C6 GPIO | Function | Notes |--------------|---------------|----------|-------| SDA | GPIO4 | I2C Data | With 4.7kŒ© pull-up to 3.3V | SCL | GPIO5 | I2C Clock | With 4.7kŒ© pull-up to 3.3V | VDD | 3.3V | Power Supply | | GND | GND | Ground | | INT | GPIO15 (optional) | Interrupt Output | Open-drain, requires pull-up | ### Test Indicator | Signal | ESP32-C6 GPIO | Function |--------|---------------|----------| Test Progress | GPIO14 | Visual test progression indicator | ### I2C Address Configuration The PCAL9555 I2C address is determined by the A0, A1, and A2 address pins: | A2 | A1 | A0 | I2C Address (7-bit) | I2C Address (8-bit) |----|----|----|---------------------|---------------------| GND | GND | GND | 0x20 | 0x40 | GND | GND | VDD | 0x21 | 0x42 | GND | VDD | GND | 0x22 | 0x44 | GND | VDD | VDD | 0x23 | 0x46 | VDD | GND | GND | 0x24 | 0x48 | VDD | GND | VDD | 0x25 | 0x4A | VDD | VDD | GND | 0x26 | 0x4C | VDD | VDD | VDD | 0x27 | 0x4E | **Default**: All address pins to GND = **0x20** (used in examples) --- ## üõ†Ô∏è Hardware Setup ### Basic Setup 1. **Connect I2C Bus**: - Connect PCAL9555 SDA to ESP32-C6 GPIO4 - Connect PCAL9555 SCL to ESP32-C6 GPIO5 - Add 4.7kŒ© pull-up resistors on both SDA and SCL to 3.3V 2. **Power Connections**: - Connect PCAL9555 VDD to ESP32-C6 3.3V - Connect PCAL9555 GND to ESP32-C6 GND 3. **Optional Interrupt**: - Connect PCAL9555 INT to ESP32-C6 GPIO15 (with pull-up resistor) 4. **Address Configuration**: - Connect A0, A1, A2 to GND for default address 0x20 - Or configure for different address if needed ### Test Setup For comprehensive testing, you can connect: - LEDs to output pins (with current-limiting resistors) - Switches/buttons to input pins - External pull-up/pull-down resistors for testing - Logic analyzer on I2C bus for protocol verification --- ## üöÄ Building the Tests ### Prerequisites 1. **Install ESP-IDF** (if not already installed): ```bash # Clone ESP-IDF git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf # Checkout release version 5.5 git checkout release/v5.5 git submodule update --init --recursive # Install ESP-IDF (Linux/macOS) ./install.sh esp32c6 # Set up environment (add to ~/.bashrc or ~/.zshrc for persistence) ./export.sh ``` 2. **Navigate to ESP32 Examples**: ```bash cd examples/esp32 ``` 3. **Setup Repository** (First time only): ```bash # Make scripts executable and setup the build environment chmod +x scripts/*.sh ./scripts/setup_repo.sh ``` ### Available Test Applications The test suites use a centralized build system with scripts. Available applications: | **Application Name** | **Description** | **Hardware Required** |----------------------|----------------|----------------------| `pcal9555_comprehensive_test` | Comprehensive PCAL9555 GPIO expander testing with all features | PCAL9555 board | ### List Available Applications ```bash # List all available applications ./scripts/build_app.sh list ``` ### Build an Application ```bash # Build comprehensive test (Debug build) ./scripts/build_app.sh pcal9555_comprehensive_test Debug # Build comprehensive test (Release build) ./scripts/build_app.sh pcal9555_comprehensive_test Release ``` --- ## üì§ Running the Tests ### Flash Application ```bash # Flash the application to ESP32-C6 ./scripts/flash_app.sh pcal9555_comprehensive_test Debug # Or manually: idf.py -p /dev/ttyUSB0 flash ``` ### Monitor Output ```bash # Monitor serial output idf.py -p /dev/ttyUSB0 monitor # Or use the flash script which includes monitoring ./scripts/flash_app.sh pcal9555_comprehensive_test Debug ``` ### Auto-detect Port ```bash # The scripts can auto-detect the port ./scripts/detect_ports.sh ``` --- ## üß™ Test Suites ### Comprehensive Test Suite **Application**: `pcal9555_comprehensive_test` This comprehensive test suite validates all PCAL9555 functionality: #### Test Sections 1. **Initialization Tests** - I2C bus initialization - Driver initialization - Reset to default state 2. **GPIO Direction Tests** - Single pin direction configuration (input/output) - Multiple pin direction configuration - Port-level direction control 3. **GPIO Read/Write Tests** - Pin write operations (HIGH/LOW) - Pin read operations - Pin toggle operations - Port-level read/write 4. **Pull Resistor Tests** - Pull-up resistor configuration - Pull-down resistor configuration - Pull enable/disable - Per-pin pull configuration 5. **Drive Strength Tests** - All drive strength levels (Level0-Level3) - Per-pin drive strength configuration 6. **Output Mode Tests** - Push-pull mode configuration - Open-drain mode configuration - Port-level output mode control 7. **Polarity Tests** - Input polarity inversion (normal/inverted) - Single pin polarity configuration - Multiple pin polarity configuration 8. **Input Latch Tests** - Input latch enable/disable - Single pin latch configuration - Multiple pin latch configuration 9. **Interrupt Tests** - Interrupt mask configuration - Interrupt status reading - Interrupt callback registration 10. **Port Operation Tests** - Port 0 operations (pins 0-7) - Port 1 operations (pins 8-15) - Mixed port operations 11. **Error Handling Tests** - Invalid pin handling - Error flag management - Error recovery 12. **Stress Tests** - Rapid pin operations - Continuous read/write cycles - Multi-pin simultaneous operations #### Test Configuration You can enable/disable specific test sections by editing the test file: ```cpp // In PCAL9555ComprehensiveTest.cpp static constexpr bool ENABLE_INITIALIZATION_TESTS = true; static constexpr bool ENABLE_GPIO_DIRECTION_TESTS = true; // ... etc ``` #### Test Results The test framework provides: - Automatic pass/fail tracking - Execution time measurement - GPIO14 progress indicator (toggles on each test) - Comprehensive test summary - Success percentage calculation --- ## üîß Configuration ### I2C Bus Configuration Default I2C configuration (can be modified in test file): ```cpp Esp32Pcal9555Bus::I2CConfig config; config.port = I2C_NUM_0; config.sda_pin = GPIO_NUM_4; // SDA pin config.scl_pin = GPIO_NUM_5; // SCL pin config.frequency = 400000; // 400 kHz config.pullup_enable = true; // Enable internal pullups ``` ### PCAL9555 Address Default I2C address (can be modified in test file): ```cpp static constexpr uint8_t PCAL9555_I2C_ADDRESS = 0x20; // Default address ``` --- ## üêõ Troubleshooting ### I2C Communication Failures **Symptoms**: Tests fail with I2C errors **Solutions**: 1. **Check I2C connections**: - Verify SDA/SCL connections - Check pull-up resistors (4.7kŒ© recommended) - Ensure proper power connections 2. **Verify I2C address**: - Check A0, A1, A2 pin configuration - Use I2C scanner to detect device address - Update `PCAL9555_I2C_ADDRESS` if different 3. **Check I2C bus speed**: - Reduce frequency if using long wires - Try 100 kHz instead of 400 kHz 4. **Verify power supply**: - Ensure 3.3V is stable - Check for voltage drops ### Build Errors **Symptoms**: CMake or compilation errors **Solutions**: 1. **Verify ESP-IDF version**: ```bash idf.py --version # Should show ESP-IDF v5.5 or compatible ``` 2. **Clean and rebuild**: ```bash idf.py fullclean ./scripts/build_app.sh pcal9555_comprehensive_test Debug ``` 3. **Check component paths**: - Verify component CMakeLists.txt paths - Ensure source files are accessible ### Test Failures **Symptoms**: Specific tests fail **Solutions**: 1. **Check hardware connections**: - Verify all pins are properly connected - Check for loose connections 2. **Review test logs**: - Check which specific test failed - Review error messages in serial output 3. **Verify device state**: - Reset PCAL9555 (power cycle) - Run reset test first --- ## üìö Additional Resources - [PCAL9555 Datasheet](/hf-pcal95555-driver/development/datasheet/PCAL9555A.pdf) - [Driver API Documentation](/hf-pcal95555-driver/development/docs/api_reference.html) - [Platform Integration Guide](/hf-pcal95555-driver/development/docs/platform_integration/) - [Hardware Overview](../../docs/hardware_overview.md) --- ## üéØ Quick Reference ### Build Commands ```bash # List available apps ./scripts/build_app.sh list # Build comprehensive test ./scripts/build_app.sh pcal9555_comprehensive_test Debug # Flash and monitor ./scripts/flash_app.sh pcal9555_comprehensive_test Debug ``` ### Test Execution The comprehensive test suite runs automatically on boot and provides: - Real-time test progress via GPIO14 indicator - Serial output with detailed test results - Automatic test summary at completion ### GPIO14 Test Indicator GPIO14 toggles between HIGH/LOW for each completed test, providing visual feedback: - Use oscilloscope or logic analyzer to monitor - Useful for automated test verification - Blinks 5 times at section start/end --- ## üìù Notes - **I2C Pull-ups**: External pull-up resistors (4.7kŒ©) are recommended even if internal pullups are enabled - **Address Configuration**: Default address is 0x20. Modify if using different A0/A1/A2 configuration - **Test Duration**: Comprehensive test suite takes approximately 2-5 minutes to complete - **Hardware Requirements**: Basic tests work without external hardware; some tests benefit from LEDs/switches --- üéØ Ready to test the PCAL9555? Start with: ./scripts/build_app.sh pcal9555_comprehensive_test Debug ",
    "url": "/hf-pcal95555-driver/development/examples/esp32/",
    
    "relUrl": "/examples/esp32/"
  }
}
